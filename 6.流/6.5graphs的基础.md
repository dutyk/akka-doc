# 依赖
要使用Akka Streams，请将模块添加到您的项目中：
```xml
<properties>
  <akka.version>2.6.10</akka.version>
  <scala.binary.version>2.13</scala.binary.version>
</properties>
<dependency>
  <groupId>com.typesafe.akka</groupId>
  <artifactId>akka-stream_${scala.binary.version}</artifactId>
  <version>${akka.version}</version>
</dependency>
```
# 介绍
在Akka Streams中，计算图不是像线性计算那样使用流畅的DSL来表达，而是将它们写在更具图形相似性的DSL中，旨在进行翻译图形绘制(例如，来自设计讨论的注释或协议规范中的插图)往返代码更简单。在本节中，我们将深入探讨构造和重用图形的多种方法，并说明常见的陷阱以及如何避免它们。
每当您要执行任何类型的扇入("多个输入")或扇出("多个输出")操作时，都需要图。考虑到线性流就像道路，我们可以将图形操作描绘为路口：多个流在单个点处连接。一些足够常见且适合于流的线性样式的运算符，例如concat(将两个流连接起来，使得第二个流在第一个流完成后被消耗)，可能在Flow或Source上定义了简写方法，但是您应该记住，它们也被实现为图结。
# 构造图
图是由简单的Flow(用作图形中的线性连接)以及用作Flow的扇入点和扇出点的结点构建的。由于联结基于它们的行为具有有意义的类型并将它们设为显式元素，因此这些元素应该非常易于使用。
Akka Streams当前提供以下联结(有关详细列表，请参见操作符索引)：
- 扇出
 - Broadcast <T> –(1个输入，N个输出)给定一个输入元素，向每个输出发出
 - Balance <T> –(1个输入，N个输出)给定一个输入元素发射到其输出端口之一
 - UnzipWith<In，A，B，...> –(1个输入，N个输出)采用1个输入的功能，给定每个输入的值会发出N个输出元素(其中N <= 20)
 - UnZip<A，B> –(1个输入，2个输出)将Pair <A，B>元组的流分成两个流，一个为A型，另一个为B型
- 扇入
 - Merge<In> –(N个输入，1个输出)从输入中随机选择，将它们一一推送到其输出
 - MergePreferred <In> –类似于Merge，但是如果元素在首选端口上可用，它将从中选择，否则从其他端口中随机选择
 - MergePrioritized<In> –类似于Merge，但是如果元素在所有输入端口上均可用，它将根据其优先级从它们中随机选择
 - MergeLatest<In> –(N个输入，1个输出)发出List [In]，当第i个输入流发出元素时，则更新发出列表中的第i个元素
 - MergeSequence <In> –(N个输入，1个输出)发出List [In]，其中输入流必须表示一个分区序列，该序列必须按顺序合并在一起
 - ZipWith <A，B，...，Out> –(N个输入，1个输出)，具有N个输入的功能，为每个输入赋予一个值，它发出1个输出元素
 - Zip <A，B> –(2输入，1输出)是一个ZipWith，专门用于将A和B的输入流压缩为Pair(A，B)元组流
 - Concat <A> –(2个输入，1个输出)连接两个流(第一个消耗一个，然后第二个消耗)
GraphDSL DSL的目标之一是看起来类似于在白板上绘制图形的方式，因此可以很容易地将设计从白板转换为代码，并能够将这两者关联起来。让我们通过将下面的手绘图转换为Akka Streams来说明这一点：
![avatar](https://doc.akka.io/docs/akka/current/images/simple-graph-example.png)
这种图形很容易转换为图形DSL，因为每个线性元素都对应于一个流，并且每个圆都对应于一个结点或源或接收器(如果它是流的开始或结束)。
```java
import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.stream.ClosedShape;
import akka.stream.Outlet;
import akka.stream.UniformFanInShape;
import akka.stream.UniformFanOutShape;
import akka.stream.javadsl.*;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletionStage;

public class GraphApp1 {
    public static void main(String[] args) {
        final ActorSystem system = ActorSystem.create("Graphs");

        final Source<Integer, NotUsed> in = Source.from(Arrays.asList(1, 2, 3, 4, 5));
        final Sink<List<String>, CompletionStage<List<String>>> sink = Sink.head();
        final Flow<Integer, Integer, NotUsed> f1 = Flow.of(Integer.class).map(elem -> elem + 10);
        final Flow<Integer, Integer, NotUsed> f2 = Flow.of(Integer.class).map(elem -> elem + 20);
        final Flow<Integer, String, NotUsed> f3 = Flow.of(Integer.class).map(elem -> elem.toString());
        final Flow<Integer, Integer, NotUsed> f4 = Flow.of(Integer.class).map(elem -> elem + 30);

        final RunnableGraph<CompletionStage<List<String>>> result =
                RunnableGraph.fromGraph(
                        GraphDSL // create() function binds sink, out which is sink's out port and builder DSL
                                .create( // we need to reference out's shape in the builder DSL below (in to()
                                        // function)
                                        sink, // previously created sink (Sink)
                                        (builder, out) -> { // variables: builder (GraphDSL.Builder) and out (SinkShape)
                                            final UniformFanOutShape<Integer, Integer> bcast =
                                                    builder.add(Broadcast.create(2));
                                            final UniformFanInShape<Integer, Integer> merge = builder.add(Merge.create(2));

                                            final Outlet<Integer> source = builder.add(in).out();
                                            builder
                                                    .from(source)
                                                    .via(builder.add(f1))
                                                    .viaFanOut(bcast)
                                                    .via(builder.add(f2))
                                                    .viaFanIn(merge)
                                                    .via(builder.add(f3.grouped(1000)))
                                                    .to(out); // to() expects a SinkShape
                                            builder.from(bcast).via(builder.add(f4)).toFanIn(merge);
                                            return ClosedShape.getInstance();
                                        }));
        CompletionStage<List<String>> strs = result.run(system);
        strs.thenAccept(s -> System.out.println(s));
    }
}
```
>注意
连接引用相等性指的是图节点相等性(即，在GraphDSL中使用的同一合并实例引用结果图中的相同位置)。
通过查看上面的代码片段，显然构建器对象是可变的。选择此设计的原因是为了简化复杂图形的创建，甚至可能包含循环。但是，一旦GraphDSL构建完成，RunnableGraph实例将是不可变的，线程安全的并且可以自由共享。所有运算符(源，sink和流)一经构建，便是如此。这意味着您可以在处理图中的多个位置安全地重用一个给定的流程或连接。
我们已经在上面看到了此类重用的示例：使用builder.add(...)将合并和广播结导入到图中，该操作将复制传递给它的蓝图并返回所得副本的入口和出口，以便可以将它们连接起来。另一种选择是将现有的任何形状的图形传递到生成新图形的工厂方法中。这两种方法之间的区别在于，使用builder.add(...)进行导入时会忽略导入图形的物化值，而通过工厂方法进行导入则允许包含该图形。有关更多详细信息，请参见流实现。
在下面的示例中，我们准备了一个由两个并行流组成的图形，在其中我们重用了相同的Flow实例，但可以正确地实现为对应的Source和Sink之间的两个连接：
```java
import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.japi.Pair;
import akka.stream.ClosedShape;
import akka.stream.UniformFanOutShape;
import akka.stream.javadsl.*;

import java.util.concurrent.CompletionStage;

public class GraphApp12 {
    public static void main(String[] args) {
        final ActorSystem system = ActorSystem.create("Graphs");

        final Sink<Integer, CompletionStage<Integer>> topHeadSink = Sink.head();
        final Sink<Integer, CompletionStage<Integer>> bottomHeadSink = Sink.head();
        final Flow<Integer, Integer, NotUsed> sharedDoubler =
                Flow.of(Integer.class).map(elem -> elem * 2);

        final RunnableGraph<Pair<CompletionStage<Integer>, CompletionStage<Integer>>> g =
                RunnableGraph.<Pair<CompletionStage<Integer>, CompletionStage<Integer>>>fromGraph(
                        GraphDSL.create(
                                topHeadSink, // import this sink into the graph
                                bottomHeadSink, // and this as well
                                Keep.both(),
                                (b, top, bottom) -> {
                                    final UniformFanOutShape<Integer, Integer> bcast = b.add(Broadcast.create(2));

                                    b.from(b.add(Source.single(1)))
                                            .viaFanOut(bcast)
                                            .via(b.add(sharedDoubler))
                                            .to(top);
                                    b.from(bcast).via(b.add(sharedDoubler)).to(bottom);
                                    return ClosedShape.getInstance();
                                }));
        // #graph-dsl-reusing-a-flow
        final Pair<CompletionStage<Integer>, CompletionStage<Integer>> pair = g.run(system);

        pair.first().thenAccept(s -> System.out.println(s));
        pair.second().thenAccept(s -> System.out.println(s));

    }
}
```
在某些情况下，例如，如果它们是动态创建的，我们可能会有一系列图元素。如果这些图具有相似的签名，我们可以构造一个图，以收集其所有物化值作为一个集合：
```java
import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.stream.*;
import akka.stream.javadsl.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;

public class GraphApp2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        final ActorSystem system = ActorSystem.create("Graphs");

        // create the source
        final Source<String, NotUsed> in = Source.from(Arrays.asList("ax", "bx", "cx"));
        // generate the sinks from code
        List<String> prefixes = Arrays.asList("a", "b", "c");
        final List<Sink<String, CompletionStage<String>>> list = new ArrayList<>();
        for (String prefix : prefixes) {
            final Sink<String, CompletionStage<String>> sink =
                    Flow.of(String.class)
                            .filter(str -> str.startsWith(prefix))
                            .toMat(Sink.head(), Keep.right());
            list.add(sink);
        }

        final RunnableGraph<List<CompletionStage<String>>> g =
                RunnableGraph.fromGraph(
                        GraphDSL.create(
                                list,
                                (GraphDSL.Builder<List<CompletionStage<String>>> builder,
                                 List<SinkShape<String>> outs) -> {
                                    final UniformFanOutShape<String, String> bcast =
                                            builder.add(Broadcast.create(outs.size()));

                                    final Outlet<String> source = builder.add(in).out();
                                    builder.from(source).viaFanOut(bcast);

                                    for (SinkShape<String> sink : outs) {
                                        builder.from(bcast).to(sink);
                                    }

                                    return ClosedShape.getInstance();
                                }));
        List<CompletionStage<String>> result = g.run(system);
        CompletionStage<List<String>> strs = CompletableFuture.completedFuture(new ArrayList<>());

        for (CompletionStage<String> stringCompletionStage : result) {
            strs = strs.thenCombine(stringCompletionStage, (s1, s2) -> {
                s1.add(s2);
                return s1;
            });
        }

        System.out.println(strs.toCompletableFuture().get());
    }
}
```
# 构造和组合部分图
有时不可能(或不需要)在一个地方构造整个计算图，而是在不同地方构造所有计算阶段，最后将它们全部连接成一个完整的图并运行它。
这可以通过使用从GraphDSL.create()返回的Graph而不是将其传递到RunnableGraph.fromGraph()并将其包装在RunnableGraph中来实现。将其表示为不同类型的原因是RunnableGraph要求所有端口为如果没有连接，则会在构造时抛出异常，这有助于避免在处理图形时出现简单的接线错误。但是，局部图允许您从执行内部接线的代码块中返回尚未连接的端口集。
假设我们要为用户提供一个特殊的元素，给定3个输入，它将选择每个压缩三元组中最大的int值。我们将要公开3个输入端口(未连接的源)和一个输出端口(未连接的接收器)。
```java

import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.stream.ClosedShape;
import akka.stream.FanInShape2;
import akka.stream.Graph;
import akka.stream.UniformFanInShape;
import akka.stream.javadsl.*;

import java.util.Arrays;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;

public class GraphApp3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        final ActorSystem system = ActorSystem.create("Graphs");

        final Graph<FanInShape2<Integer, Integer, Integer>, NotUsed> zip =
                ZipWith.create((Integer left, Integer right) -> Math.max(left, right));

        final Graph<UniformFanInShape<Integer, Integer>, NotUsed> pickMaxOfThree =
                GraphDSL.create(
                        builder -> {
                            final FanInShape2<Integer, Integer, Integer> zip1 = builder.add(zip);
                            final FanInShape2<Integer, Integer, Integer> zip2 = builder.add(zip);

                            builder.from(zip1.out()).toInlet(zip2.in0());
                            // return the shape, which has three inputs and one output
                            return UniformFanInShape.<Integer, Integer>create(
                                    zip2.out(), Arrays.asList(zip1.in0(), zip1.in1(), zip2.in1()));
                        });

        final Sink<Integer, CompletionStage<Integer>> resultSink = Sink.<Integer>head();

        final RunnableGraph<CompletionStage<Integer>> g =
                RunnableGraph.<CompletionStage<Integer>>fromGraph(
                        GraphDSL.create(
                                resultSink,
                                (builder, sink) -> {
                                    // import the partial graph explicitly
                                    final UniformFanInShape<Integer, Integer> pm = builder.add(pickMaxOfThree);

                                    builder.from(builder.add(Source.single(1))).toInlet(pm.in(0));
                                    builder.from(builder.add(Source.single(2))).toInlet(pm.in(1));
                                    builder.from(builder.add(Source.single(3))).toInlet(pm.in(2));
                                    builder.from(pm.out()).to(sink);
                                    return ClosedShape.getInstance();
                                }));

        final CompletionStage<Integer> max = g.run(system);

        max.thenAccept(m -> System.out.println(m));
    }
}
```
注意
虽然上面的示例显示了组成两个2输入的ZipWith，但是实际上ZipWith已经提供了许多重载，包括3个(以及更多)参数版本。因此，可以使用一个使用3参数版本的ZipWith来实现，如下所示：ZipWith.create((a，b，c)-> out)。 (带有N输入的ZipWith具有N + 1类型参数；最后一个类型参数是输出类型。)
如您所见，首先我们构造部分图，该图描述了如何计算两个输入流的最大值。然后我们在构造将其扩展到三个输入流的部分图时重用两次。然后，将其(所有节点和连接)显式导入最后一个图形，在该图形中，所有未定义的元素都重新连接到实际的源和接收器。然后可以运行该图并产生预期的结果。
>警告
请注意，GraphDSL无法提供有关所有元素是否已正确连接的编译时类型安全性-此验证是在图形实例化期间作为运行时检查执行的。
部分图形还可以验证所有端口是否已连接或已返回Shape的一部分。
# 从局部图构造源，sink和流
代替将图视为可能尚未全部连接的流和连接的集合，有时将这样的复杂图公开为更简单的结构(如源，接收器或流)很有用。
实际上，这些概念可以表示为部分连接图的特殊情况：
- Source是仅具有一个输出的部分图形，即它返回SourceShape。
- 接收器是仅具有一个输入的部分图形，即它返回一个SinkShape。
- Flow是具有一个输入和一个输出的部分图形，即它返回一个FlowShape。
能够在诸如Sink/Source/Flow之类的简单元素中隐藏复杂图形，使您能够创建一个复杂元素，然后将其视为用于线性计算的简单复合运算符。
为了从图创建Source，要使用Source.fromGraph方法，要使用它，我们必须有一个带有SourceShape的Graph。这是使用GraphD.create构建的，并提供了构建SourceShape图的功能。必须将单个出口提供给SourceShape.of方法，并将成为"必须运行此Source之前必须连接的接收器"。
请参考下面的示例，在该示例中，我们创建了一个将两个数字压缩在一起的Source，以查看此图形的实际效果：
```java

import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.japi.Pair;
import akka.stream.FanInShape2;
import akka.stream.SourceShape;
import akka.stream.javadsl.*;

import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;

public class GraphApp4 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        final ActorSystem system = ActorSystem.create("Graphs");

        final Source<Integer, NotUsed> ints = Source.fromIterator(() -> new Ints());

        final Source<Pair<Object, Object>, NotUsed> pairs =
                Source.fromGraph(
                        GraphDSL.create(
                                builder -> {
                                    final FanInShape2<Object, Object, Pair<Object, Object>> zip =
                                            builder.add(Zip.create());

                                    builder.from(builder.add(ints.filter(i -> i % 2 == 0))).toInlet(zip.in0());
                                    builder.from(builder.add(ints.filter(i -> i % 2 == 1))).toInlet(zip.in1());

                                    return SourceShape.of(zip.out());
                                }));

        final CompletionStage<Pair<Object, Object>> firstPair =
                pairs.runWith(Sink.head(), system);

        firstPair.thenAccept(s -> System.out.println(s));
    }
}
```
类似地，可以使用SinkShape.of对Sink<T>执行相同的操作，在这种情况下，提供的值必须是Inlet <T>。 为了定义Flow <T>，我们需要同时公开一个未定义的源和接收器：
```java
import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.japi.Pair;
import akka.stream.FanInShape2;
import akka.stream.FlowShape;
import akka.stream.UniformFanOutShape;
import akka.stream.javadsl.*;

import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;

public class GraphApp5 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        final ActorSystem system = ActorSystem.create("Graphs");

        final Source<Integer, NotUsed> ints = Source.fromIterator(() -> new Ints());

        final Flow<Integer, Pair<Integer, String>, NotUsed> pairs =
                Flow.fromGraph(
                        GraphDSL.create(
                                b -> {
                                    final UniformFanOutShape<Integer, Integer> bcast = b.add(Broadcast.create(2));
                                    final FanInShape2<Integer, String, Pair<Integer, String>> zip =
                                            b.add(Zip.create());

                                    b.from(bcast).toInlet(zip.in0());
                                    b.from(bcast)
                                            .via(b.add(Flow.of(Integer.class).map(i -> i.toString())))
                                            .toInlet(zip.in1());

                                    return FlowShape.of(bcast.in(), zip.out());
                                }));

        final CompletionStage<Pair<Integer, String>> firstPair =
                Source.single(1).via(pairs).runWith(Sink.<Pair<Integer, String>>head(), system);

        firstPair.thenAccept(s -> System.out.println(s));
    }
}
```
# 将源和接收器与简化的API结合
您可以使用简化的API将源和接收器与结点结合起来，例如：Broadcast <T>，Balance <T>，Merge <In>和Concat <A>，而无需使用Graph DSL。 Combine方法负责在下面构造必要的图。 在以下示例中，我们将两个来源合并为一个（扇入）：
```java
import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.stream.javadsl.Merge;
import akka.stream.javadsl.Sink;
import akka.stream.javadsl.Source;

import java.util.ArrayList;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;

public class GraphApp6 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        final ActorSystem system = ActorSystem.create("Graphs");

        Source<Integer, NotUsed> source1 = Source.single(1);
        Source<Integer, NotUsed> source2 = Source.single(2);

        final Source<Integer, NotUsed> sources =
                Source.combine(source1, source2, new ArrayList<>(), i -> Merge.<Integer>create(i));

        CompletionStage<Integer> result = sources.runWith(Sink.<Integer, Integer>fold(0, (a, b) -> a + b), system);

        result.thenAccept(s -> System.out.println(s));
    }
}
```
可以对接收器执行相同的操作，但是在这种情况下，它将扇出：
```java
import akka.Done;
import akka.NotUsed;
import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.stream.javadsl.Broadcast;
import akka.stream.javadsl.Sink;
import akka.stream.javadsl.Source;
import akka.testkit.javadsl.TestKit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.CompletionStage;

public class GraphAppTest {
    static ActorSystem system;

    @BeforeClass
    public static void setup() {
        system = ActorSystem.create("StreamPartialGraphDSLDocTest");
    }

    @AfterClass
    public static void tearDown() {
        TestKit.shutdownActorSystem(system);
        system = null;
    }

    @Test
    public  void demonstrateBuildSinkWithCombine() throws Exception {
        final TestKit probe = new TestKit(system);
        ActorRef actorRef = probe.getRef();

        // #sink-combine
        Sink<Integer, NotUsed> sendRemotely = Sink.actorRef(actorRef, "Done");
        
        Sink<Integer, CompletionStage<Done>> localProcessing =
                Sink.<Integer>foreach(
                        a -> {
                            System.out.println(a);
                        });
        Sink<Integer, NotUsed> sinks =
                Sink.combine(sendRemotely, localProcessing, new ArrayList<>(), a -> Broadcast.create(a));

        Source.<Integer>from(Arrays.asList(new Integer[] {0, 1, 2})).runWith(sinks, system);
        // #sink-combine
        probe.expectMsgEquals(0);
        probe.expectMsgEquals(1);
        probe.expectMsgEquals(2);
    }

}
```
# 构建可重用的Graph组件
使用图形DSL可以构建任意输入和输出端口的可重用的封装组件。
例如，我们将建立一个表示worker池的图形结，其中一个工人表示为Flow <I，O，M>，即将类型I的作业简单转换为类型O的结果（当您已经看到，该流实际上可以在其中包含一个复杂的图）。 我们可重复使用的worker池联结将不保留传入作业的顺序（假定它们具有正确的ID字段），它将使用Balance联结将作业调度给可用的工人。 最重要的是，我们的路口将设有一个“快速通道”，这是一个专用端口，可以发送更高优先级的作业。
总而言之，我们的结点将具有两个类型I的输入端口（用于普通作业和优先级作业）和一个类型O的输出端口。要表示此接口，我们需要定义一个自定义Shape。 以下几行显示了如何执行此操作。
```scala
import akka.stream.{Inlet, Outlet, Shape}
import scala.collection.immutable

// A shape represents the input and output ports of a reusable
// processing module
case class PriorityWorkerPoolShape[In, Out](jobsIn: Inlet[In], priorityJobsIn: Inlet[In], resultsOut: Outlet[Out])
  extends Shape {

  // It is important to provide the list of all input and output
  // ports with a stable order. Duplicates are not allowed.
  override val inlets: immutable.Seq[Inlet[_]] =
  jobsIn :: priorityJobsIn :: Nil
  override val outlets: immutable.Seq[Outlet[_]] =
    resultsOut :: Nil

  // A Shape must be able to create a copy of itself. Basically
  // it means a new instance with copies of the ports
  override def deepCopy() =
    PriorityWorkerPoolShape(jobsIn.carbonCopy(), priorityJobsIn.carbonCopy(), resultsOut.carbonCopy())

}
```
# 预定义形状
通常，自定义Shape需要能够提供其所有输入和输出端口，能够复制自身，还必须能够从给定端口创建新实例。 提供了一些预定义的形状以避免不必要的样板：
- SourceShape，SinkShape，FlowShape可简化形状，
- UniformFanInShape和UniformFanOutShape用于与多个具有相同类型的输入(或输出)端口的联结，
- FanInShape1，FanInShape2，...，FanOutShape1，FanOutShape2，...用于与具有不同类型的多个输入(或输出)端口的连接。
由于我们的形状具有两个输入端口和一个输出端口，因此我们可以使用FanInShape DSL定义我们的自定义形状：
```scala
import akka.stream.FanInShape
import akka.stream.FanInShape.{Init, Name}

class PriorityWorkerPoolShape2[In, Out](_init: Init[Out] = Name("PriorityWorkerPool"))
  extends FanInShape[Out](_init) {
  protected override def construct(i: Init[Out]) = new PriorityWorkerPoolShape2(i)

  val jobsIn = newInlet[In]("jobsIn")
  val priorityJobsIn = newInlet[In]("priorityJobsIn")
  // Outlet[Out] with name "out" is automatically created
}
```
现在我们有了一个Shape可以连接代表我们的worker池的图。首先，我们将使用合并传入的常规和优先级作业MergePreferred，然后将其发送到一个Balance结点，该结点将扇出到可配置数量的工作程序(流)，最后我们将所有这些结果合并在一起，并通过输出端口。这由以下代码表示：
```scala
import akka.stream.{Inlet, Outlet, Shape}
import scala.collection.immutable

// A shape represents the input and output ports of a reusable
// processing module
case class PriorityWorkerPoolShape[In, Out](jobsIn: Inlet[In], priorityJobsIn: Inlet[In], resultsOut: Outlet[Out])
  extends Shape {

  // It is important to provide the list of all input and output
  // ports with a stable order. Duplicates are not allowed.
  override val inlets: immutable.Seq[Inlet[_]] =
  jobsIn :: priorityJobsIn :: Nil
  override val outlets: immutable.Seq[Outlet[_]] =
    resultsOut :: Nil

  // A Shape must be able to create a copy of itself. Basically
  // it means a new instance with copies of the ports
  override def deepCopy() =
    PriorityWorkerPoolShape(jobsIn.carbonCopy(), priorityJobsIn.carbonCopy(), resultsOut.carbonCopy())

}
```
现在我们要做的就是在图形中使用我们的自定义结。以下代码使用纯字符串模拟一些简单的工作程序和作业，并打印出结果。实际上，我们使用了两次worker池联结实例add()。
```scala
import akka.actor.ActorSystem
import akka.stream.ClosedShape
import akka.stream.scaladsl.{Flow, GraphDSL, RunnableGraph, Sink, Source}

object GraphApp extends App {
  implicit val system = ActorSystem.create("GraphApp")

  implicit val ec = system.dispatcher

  val worker1 = Flow[String].map("step 1 " + _)
  val worker2 = Flow[String].map("step 2 " + _)

  RunnableGraph
    .fromGraph(GraphDSL.create() { implicit b =>
      import GraphDSL.Implicits._

      val priorityPool1 = b.add(PriorityWorkerPool(worker1, 4))
      val priorityPool2 = b.add(PriorityWorkerPool(worker2, 2))

      Source(1 to 100).map("job: " + _) ~> priorityPool1.jobsIn
      Source(1 to 100).map("priority job: " + _) ~> priorityPool1.priorityJobsIn

      priorityPool1.resultsOut ~> priorityPool2.jobsIn
      Source(1 to 100).map("one-step, priority " + _) ~> priorityPool2.priorityJobsIn

      priorityPool2.resultsOut ~> Sink.foreach(println)
      ClosedShape
    })
    .run()
}
```
# 双向流
通常有用的图拓扑是两个方向相反的流。以一个编解码器运算符为例，该运算符对传出的消息进行序列化，并对输入的八位位组流进行反序列化。另一个这样的运算符可以添加成帧协议，该协议将长度报头附加到传出数据，并将传入的帧解析回原始八位位组流块。这两个运算符是要组成的，将一个运算符放在另一个运算符上作为协议栈的一部分。为此，存在一种特殊类型BidiFlow，它是一种图形，它具有两个完全开放的入口和两个完全开放的出口。相应的形状被调用BidiShape并定义如下：
```scala
import akka.stream.{FlowShape, Inlet, Outlet, Shape}
import scala.annotation.unchecked.uncheckedVariance
import scala.collection.immutable

/**
 * A bidirectional flow of elements that consequently has two inputs and two
 * outputs, arranged like this:
 *
 * {{{
 *        +------+
 *  In1 ~>|      |~> Out1
 *        | bidi |
 * Out2 <~|      |<~ In2
 *        +------+
 * }}}
 */
final case class BidiShape[-In1, +Out1, -In2, +Out2](
                                                      in1: Inlet[In1 @uncheckedVariance],
                                                      out1: Outlet[Out1 @uncheckedVariance],
                                                      in2: Inlet[In2 @uncheckedVariance],
                                                      out2: Outlet[Out2 @uncheckedVariance])
  extends Shape {
  override val inlets: immutable.Seq[Inlet[_]] = in1 :: in2 :: Nil
  override val outlets: immutable.Seq[Outlet[_]] = out1 :: out2 :: Nil

  /**
   * Java API for creating from a pair of unidirectional flows.
   */
  def this(top: FlowShape[In1, Out1], bottom: FlowShape[In2, Out2]) = this(top.in, top.out, bottom.in, bottom.out)

  override def deepCopy(): BidiShape[In1, Out1, In2, Out2] =
    BidiShape(in1.carbonCopy(), out1.carbonCopy(), in2.carbonCopy(), out2.carbonCopy())

}
```
第一个版本类似于部分图构造器，而对于功能1：1转换的简单情况，有一种简洁的方便方法，如最后一行所示。这两个功能的实现也不难：
```java
trait Message
case class Ping(id: Int) extends Message
case class Pong(id: Int) extends Message

def toBytes(msg: Message): ByteString = {
  implicit val order = ByteOrder.LITTLE_ENDIAN
  msg match {
    case Ping(id) => ByteString.newBuilder.putByte(1).putInt(id).result()
    case Pong(id) => ByteString.newBuilder.putByte(2).putInt(id).result()
  }
}

def fromBytes(bytes: ByteString): Message = {
  implicit val order = ByteOrder.LITTLE_ENDIAN
  val it = bytes.iterator
  it.getByte match {
    case 1     => Ping(it.getInt)
    case 2     => Pong(it.getInt)
    case other => throw new RuntimeException(s"parse error: expected 1|2 got $other")
  }
}

val codecVerbose = BidiFlow.fromGraph(GraphDSL.create() { b =>
  // construct and add the top flow, going outbound
  val outbound = b.add(Flow[Message].map(toBytes))
  // construct and add the bottom flow, going inbound
  val inbound = b.add(Flow[ByteString].map(fromBytes))
  // fuse them together into a BidiShape
  BidiShape.fromFlows(outbound, inbound)
})

// this is the same as the above
val codec = BidiFlow.fromFunctions(toBytes _, fromBytes _)
```
这样，您可以集成任何其他将对象转换为字节序列的序列化库。
我们讨论的另一个运算符涉及更多，因为反转帧协议意味着任何接收到的字节块都可能对应于零个或多个消息。最好使用来实现GraphStage(另请参见使用GraphStage进行自定义处理)。
```scala
def toBytes(msg: Message): ByteString = {
  implicit val order = ByteOrder.LITTLE_ENDIAN
  msg match {
    case Ping(id) => ByteString.newBuilder.putByte(1).putInt(id).result()
    case Pong(id) => ByteString.newBuilder.putByte(2).putInt(id).result()
  }
}

def fromBytes(bytes: ByteString): Message = {
  implicit val order = ByteOrder.LITTLE_ENDIAN
  val it = bytes.iterator
  it.getByte match {
    case 1     => Ping(it.getInt)
    case 2     => Pong(it.getInt)
    case other => throw new RuntimeException(s"parse error: expected 1|2 got $other")
  }
}
```
通过这些实现，我们可以构建协议栈并对其进行测试：
```scala
import akka.stream.{FlowShape, Inlet, Outlet, Shape}
import scala.annotation.unchecked.uncheckedVariance
import scala.collection.immutable

/**
 * A bidirectional flow of elements that consequently has two inputs and two
 * outputs, arranged like this:
 *
 * {{{
 *        +------+
 *  In1 ~>|      |~> Out1
 *        | bidi |
 * Out2 <~|      |<~ In2
 *        +------+
 * }}}
 */
final case class BidiShape[-In1, +Out1, -In2, +Out2](
                                                      in1: Inlet[In1 @uncheckedVariance],
                                                      out1: Outlet[Out1 @uncheckedVariance],
                                                      in2: Inlet[In2 @uncheckedVariance],
                                                      out2: Outlet[Out2 @uncheckedVariance])
  extends Shape {
  override val inlets: immutable.Seq[Inlet[_]] = in1 :: in2 :: Nil
  override val outlets: immutable.Seq[Outlet[_]] = out1 :: out2 :: Nil

  /**
   * Java API for creating from a pair of unidirectional flows.
   */
  def this(top: FlowShape[In1, Out1], bottom: FlowShape[In2, Out2]) = this(top.in, top.out, bottom.in, bottom.out)

  override def deepCopy(): BidiShape[In1, Out1, In2, Out2] =
    BidiShape(in1.carbonCopy(), out1.carbonCopy(), in2.carbonCopy(), out2.carbonCopy())

}
```
本示例演示了如何将BidiFlow子图连接在一起，以及如何使用.reversed（）方法进行翻转。 该测试模拟了网络通信协议的双方，而无需实际打开网络连接-流可以直接连接。
# 访问图内的物化值
在某些情况下，可能需要反馈图的物化值（部分，闭合或支持源，接收器，流或BidiFlow）。 这可以通过使用builder.materializedValue来实现，该给出了一个Outlet，可以在图形中用作普通的源或出口，并最终发出该物化值。 如果在多个位置需要物化值，则可以多次调用物化值来获取必要数量的出口。
```java
```
注意不要引入一个周期，在该周期中，物化值实际上会影响物化值。 以下示例说明了fold的实现CompletionStage反馈到fold本身的情况。
```java
```
# 图生命周期、存活、死锁
有界流拓扑中的循环需要特殊考虑，以避免潜在的死锁和其他活跃性问题。 本节显示了一些因流处理图中的反馈电弧而引起的问题的示例。
在以下示例中，创建了可运行图，但由于每个图都有问题并且在启动后会死锁，因此无法运行。 源变量未定义为元素的性质和数量与所描述的问题无关。
第一个示例演示了一个包含幼稚周期的图。 该图从源中获取元素，进行打印，然后将这些元素广播给使用者（我们现在仅使用Sink.ignore）和反馈弧，该弧通过Merge结点合并回到主流中。
>注意
图形DSL允许反转连接箭头，这在编写循环时特别方便-我们将看到在某些情况下这非常有用。
```java
```
运行此命令，我们观察到在打印了一些数字之后，不再有任何元素记录到控制台-一段时间后所有处理停止。经过调查，我们发现：
- 通过合并，source我们增加了循环中流动的元素数量
- 通过广播回到周期，我们不会减少周期中的元素数量
由于Akka流（和一般的响应流）保证有界处理（请参阅“缓冲”部分以获取更多详细信息），这意味着在任何时间范围内只有有限数量的元素被缓冲。 由于我们的循环获得越来越多的元素，最终其所有内部缓冲区都变满了，永远回压。 为了能够处理来自源元素的更多元素，需要以某种方式离开循环。
如果我们通过用MergePreferred替换Merge结点来修改反馈循环，则可以避免死锁。 MergePreferred是不公平的，因为如果在尝试使用其他较低优先级的输入端口之前有可用的元素，它将始终尝试从首选输入端口进行消耗。 由于我们通过首选端口进行反馈，因此始终保证循环中的元素可以流动。
```java
```
如果运行示例，我们会看到一遍又一遍地打印相同的数字序列，但是处理不会停止。因此，我们避免了死锁，但source仍然永远背负压力，因为缓冲区空间永远不会恢复：我们看到的唯一动作是循环了两个初始元素source。
>注意
我们在这里看到的是，在某些情况下，我们需要在有界和活泼之间做出选择。如果循环中有无限的缓冲区，我们的第一个示例将不会死锁，反之亦然，如果循环中的元素是平衡的(移除的元素数量与注入的元素数量相同)，则不会出现死锁。
为了使我们的周期既活着(不死锁)又公平，我们可以在反馈弧上引入一个下降元素。在这种情况下，我们选择buffer()给它一个删除策略的操作OverflowStrategy.dropHead。
```java
```
如果运行此示例，我们将看到
元素的流动不停，总是有元素印刷
我们看到一些数字随着时间的推移多次打印(由于反馈循环)，但从长期来看，平均而言，数字正在增加
此示例强调了一种在存在潜在不平衡循环(循环元素的数量不受限制的循环)的情况下避免死锁的解决方案是删除元素。一种替代方法是定义一个较大的缓冲区，OverflowStrategy.fail该缓冲区将使流失败，而不是在耗尽所有缓冲区空间后将其死锁。
正如我们在前面的示例中发现的那样，核心问题是反馈回路的不平衡特性。我们通过添加一个放置元素来规避此问题，但现在我们要构建一个从一开始就保持平衡的循环。为了实现这一点，我们通过用替换Merge联结来修改我们的第一个图ZipWith。由于从反馈弧中ZipWith取出一个元素source 并将其注入循环中，因此我们保持了元素的平衡。
```java
```
但是，当我们尝试运行该示例时，结果表明根本没有打印任何元素！经过调查，我们意识到：
为了使第一个元素source进入循环，我们需要循环中已经存在的元素
为了获得循环中的初始元素，我们需要 source
这两个条件是典型的"鸡与蛋"问题。解决方案是将一个初始元素注入到独立于的循环中source。为此，我们Concat在向后圆弧上使用一个结点，该结点使用注入单个元素Source.single。
```java

 ```
当我们运行上面的示例时，我们看到处理开始并且永不停止。此示例的重要意义在于，平衡的循环通常需要将初始的"启动"元素注入循环中。