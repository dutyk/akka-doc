
# 动机
如今，我们从Internet上使用服务的方式包括许多流数据实例，包括从服务下载以及上传到服务或点对点数据传输。将数据视为元素流而不是全部元素是非常有用的，因为它与计算机发送和接收它们的方式(例如，通过TCP)相匹配，但由于数据集经常变得太大而无法作为整个处理，也是有必要的。我们将计算或分析分散在大型集群上，并称为“大数据”，其中处理这些数据的全部原理是通过将这些数据作为流以顺序方式通过某些CPU进行馈送。
actors也可以看作是处理流：他们发送和接收一系列消息，以便将知识(或数据)从一个地方转移到另一个地方。为了实现actors之间的稳定流，我们发现执行所有适当的措施很繁琐且容易出错，因为除了发送和接收之外，我们还需要注意不要在此过程中溢出任何缓冲区或邮箱。另一个陷阱是Actor消息可能会丢失，在这种情况下必须重新传输。否则会在接收侧造成孔洞。
由于这些原因，我们决定将这些问题的解决方案捆绑为Akka Streams API。目的是提供一种直观，安全的方式来制定流处理设置，以便我们随后可以有效地并以有限的资源使用率执行它们，而不再需要OutOfMemoryErrors。为了实现这一点，我们的流需要能够限制它们使用的缓冲，如果消费者无法跟上，它们就必须能够减慢生产者的速度。此功能称为背压，是Akka发起成员之一的Reactive Streams计划的核心。对您来说，这意味着传播和对背压作出反应这一艰巨的问题已经纳入Akka Streams的设计中，因此您无需担心什么。这也意味着Akka Streams可与所有其他Reactive Streams实现无缝互操作(其中Reactive Streams接口定义了互操作性SPI，而Akka Streams等实现则提供了不错的用户API)。
## 与反应流的关系
Akka Streams API与Reactive Streams接口完全分离。虽然Akka Streams专注于对数据流进行转换的表述，但Reactive Streams的范围是定义一种通用机制，该机制如何跨异步边界移动数据而不会造成丢失，缓冲或资源耗尽。
两者之间的关系是Akka Streams API是面向最终用户的，而Akka Streams实现则在内部使用Reactive Streams接口在不同的运营商之间传递数据。因此，您不会在Reactive Streams接口和Akka Streams API之间发现任何相似之处。这符合Reactive Streams项目的期望，Reactive Streams项目的主要目的是定义接口，以便不同的流实现可以互操作。响应流不是描述最终用户API的目的。
# 如何阅读这些文档
流处理是与Actor模型或Future组合不同的范例，因此在您熟悉工具和技术之前，可能需要仔细研究该主题。这里的文档可为您提供帮助，为了获得最佳效果，我们建议采用以下方法：
阅读《快速入门指南》，以了解流的外观和功能。
自上而下的学习者此时可能希望仔细阅读Akka Streams背后的设计原理。
自下而上的学习者可能会通过Streams Cookbook感到更自在。
有关内置处理操作员的完整概述，请查看操作员索引
其他部分可以按顺序阅读，也可以在前面的步骤中根据需要阅读，每个部分都深入探讨了特定主题。