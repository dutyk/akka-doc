# Akka Streams背后的设计原则

我们花了相当长的时间才对API的外观和实现以及实现的体系结构感到满意，并且在直觉的指导下，设计阶段是非常探索性的研究。本节详细介绍了发现，并将它们整理为在此过程中出现的一组原则。
>注意
如简介中所述，请记住，Akka Streams API与Reactive Streams接口完全分离，后者是有关如何在各个运算符之间传递流数据的实现细节。

# Akka Streams用户应该期待什么？

Akka基于有意识的决定而提供最小和一致的API，而不是简单或直观。我们的信条是，我们倾向于明确性胜过魔术，如果我们提供一个功能，那么它必须始终有效，没有例外。另一种说法是，我们尽量减少用户必须学习的规则数量，而不是试图使规则接近我们认为用户可能期望的规则。
由此可见，Akka Streams实施的原则是：
- API中的所有功能都是显式的，没有魔术
- 最高的组合性：组合件保留了每个部分的功能
- 分布式有界流处理领域的详尽模型
这意味着我们提供了表达任何流处理拓扑所必需的所有工具，为该域的所有基本方面（背压，缓冲，转换，故障恢复等）建模，并且用户构建的任何内容都可以在其中重用，在更大的范围。

## Akka Streams不会将掉线的流元素发送到死信办公室

仅提供可以依赖的功能的一个重要结果是Akka Streams无法确保通过处理拓扑发送的所有对象被处理。可以删除元素的原因有很多：
- 在map（...）运算符中，普通用户代码可以消耗的一个元素，并产生完全不同的结果
- 常见的流运算符故意删除元素，例如采取/丢弃/过滤/合并/缓冲/…
- 流故障将中断流，而无需等待处理完成，所有处于运行状态的元素将被丢弃
- 流取消将在上游传播（例如从Take操作符），导致上游处理步骤终止而未处理所有输入
这意味着将JVM对象发送到需要清除的流中将需要用户确保这发生在Akka Streams设施之外（例如，通过在超时后清理它们或在流输出中观察到它们的结果时进行清理，或使用其他方法，例如终结器等）。

## 产生的实施注意事项

组合性要求部分流拓扑可重用，这导致我们提出了一种将数据流描述为（部分）图的提升方法，这些图可以充当复合源，流（也称为管道）和数据sinks。然后，这些构建块应可以自由共享，并具有将它们自由组合以形成较大图形的能力。因此，这些片段的表示必须是在明确的步骤中实现的不变的蓝图，以便开始流处理。然后，在具有由蓝图规定的固定拓扑的意义上，所得的流处理引擎也是不可变的。需要通过显式使用Reactive Streams接口对动态网络进行建模，以将不同的引擎连接在一起。
实现过程通常会创建特定的对象，这些对象一旦运行便会与处理引擎进行交互，例如用于将其关闭或提取指标。这意味着物化函数产生的结果称为图形的物化值。

# 与其他Reactive Streams实现的互操作

Akka Streams完全实现了Reactive Streams规范，并可以与所有其他一致的实现方式进行互操作。我们选择将Reactive Streams接口与用户级API完全分开，因为我们将它们视为不面向最终用户的SPI。为了从Akka Stream拓扑获取发布者或订阅者，必须使用相应的Sink.asPublisher或Source.asSubscriber元素。
默认实现的Akka Streams所产生的所有流处理器都被限制为只有一个订户，其他订户将被拒绝。这是因为使用我们的DSL描述的流拓扑永远不需要元素的发布者端的fan-out行为，所有fan-out都是使用诸如Broadcast[T]之类的显式元素完成的。
这意味着必须在需要广播行为才能与其他Reactive Streams实现互操作的地方使用Sink.asPublisher（true）（用于启用扇出支持）。

## Sink/Source/Flow没有直接扩展Reactive Streams接口的原理和好处

关于响应式流的一个有时被忽略的关键信息是它们是服务提供者接口，正如在有关规范的早期讨论之一中所深入解释的那样。 Akka Streams是在开发Reactive Streams时设计的，因此它们彼此之间都产生了很大的影响。
令人鼓舞的是，即使在响应式规范中，这些类型最初也曾试图向API用户隐藏Publisher，Subscriber和其他SPI类型。尽管由于某些情况下这些内部SPI类型最终会暴露给标准的最终用户，所以还是决定删除API类型，而仅保留SPI类型，即Publisher，Subscriber等。
有了关于标准目的的历史知识和上下文–作为可互操作库的内部细节–我们可以肯定地说不能真正说与这些类型的直接继承关系可以视为某种形式的优势或库之间有意义的区别。相反，可以看出向最终用户公开那些SPI类型的API意外泄漏了内部实现细节。
属于Akka流的Source，Sink和Flow类型旨在提供流畅的DSL，并成为运行这些流的“工厂”。它们在响应流中的直接对应对象分别是发布者，订阅者和处理器。换句话说，Akka流在计算图的提升表示上进行操作，然后根据响应流规则将其实现并执行。这也允许Akka Streams在实现步骤中执行诸如融合和调度程序配置之类的优化。
隐藏Reactive Streams接口的另一个不明显的好处来自org.reactivestreams.Subscriber（等）现已包含在Java 9+中，并因此成为Java本身的一部分，因此库应迁移到使用java.util.concurrent.Flow.Subscriber,代替org.reactivestreams.Subscriber。选择公开和直接扩展Reactive Streams类型的库现在将很难适应JDK9 +类型-他们所有扩展Subscriber和Friends的类都将被复制或更改以扩展完全相同的接口，但是使用不同的接口包。在Akka中，我们仅在被要求时公开新类型-从JDK9发布之日起已经支持JDK9类型。
隐藏反应式流接口的另一个，也许是更重要的原因，可以追溯到该解释的第一点：反应式流是SPI的事实，因此在临时实现中很难“正确解决”。因此，Akka Streams不鼓励使用难以实现的底层基础结构，并为用户提供了更简单，更类型安全，但功能更强大的抽象供用户使用：GraphStages和运算符。当然，通过使用诸如asPublisher或fromSubscriber之类的方法，仍然（并且很容易）可以接受或获得流运算符的反应性流（或JDK + Flow）表示形式。

# 流媒体库用户应该期待什么？

我们期望库将基于Akka Streams构建，实际上Akka HTTP就是这样一个示例，它存在于Akka项目本身中。为了使用户能够从上面针对Akka Streams所描述的原理中获利，建立了以下规则：
- 库应为用户提供可重复使用的作品，即公开返回操作符的工厂，以实现完全组合
- 库可以有选择地并且额外地提供消耗和具体化操作符的设施
第一条规则背后的理由是，如果不同的库仅接受运算符并期望将它们实现，则组合性将被破坏：因为实现只能发生一次，所以不可能将它们中的两个一起使用。因此，必须表达库的功能，以便用户可以在库的控制范围之外实现。
第二条规则允许库为常见情况额外提供漂亮的糖，例如Akka HTTP API，该API提供了handleWith方法以方便实现。
>注意
这样做的一个重要后果是，可重用的流描述不能绑定到“活动”资源，必须延迟到此类资源的任何连接或分配，直到实现时间。 “实时”资源的示例是已经存在的TCP连接，多播发布者等。如果TickSource的计时器仅在实现时创建（例如我们的实现），则它不会属于此类别。
对此的例外情况需要进行充分的论证并仔细记录。

## 产生的实施约束

Akka Streams必须使库能够根据不变的蓝图表达任何流处理实用程序。最常见的构建基块是
- 来源：只有一个输出流的东西
- 接收器：只有一个输入流的东西
- 流：只有一个输入和一个输出流的东西
- BidiFlow：恰好具有两个输入流和两个输出流的概念上像两个相反方向的流一样的东西
- Graph：一种打包的流处理拓扑，它公开了一组特定的输入和输出端口，以Shape类型的对象为特征。
>注意
发出流的源仍然是正常的源，所生成的元素种类在要表达的静态流拓扑中不起作用。

# 错误和失败之间的区别

讨论的起点是反应式宣言所给出的定义。转换为流意味着在流中可以将错误作为普通数据元素来访问，而故障意味着流本身已经发生故障并且正在崩溃。具体来说，在响应流接口级别上，数据元素（包括错误）通过onNext发出信号，而失败则发出onError信号。
>注意
不幸的是，出于历史原因，用于向订阅服务器发送失败信号的方法名称为onError。始终牢记，Reactive Streams接口（发布者/订阅/订阅者）正在为在执行单元之间传递流的低级基础结构建模，而该级别的错误恰恰是我们在更高级别上谈论的失败。由Akka Streams建模。
与可用于数据元素转换的运算符相比，在Akka Streams中处理onError的支持有限，这是上一段落的精神。由于onError表示流正在崩溃，因此其排序语义与流完成的含义不同：任何类型的转换运算符都将随流而崩溃，可能仍将元素保留在隐式或显式缓冲区中。这意味着，如果onError超过了它们，则在失败之前发出的数据元素仍然可以丢失。
故障传播速度要快于数据元素，这对于拆除被反向压力的流至关重要，尤其是因为反向压力可能是故障模式（例如，通过跳闸上游缓冲区，然后由于它们无法执行其他操作而中止；或者发生死锁）。

## 流恢复的语义

恢复元素（即吸收onError信号并在正常流完成后将其转变为更多数据元素的任何转换）充当将流崩溃限制在流拓扑的给定区域的隔板。在折叠区域内，缓冲的元素可能会丢失，但外部不受故障影响。
这与try-catch表达式的工作方式相同：它标记了捕获异常的区域，但是可能无法确切知道发生故障的情况下在该区域中跳过的确切代码量–语句的放置很重要。