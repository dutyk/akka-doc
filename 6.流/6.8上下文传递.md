# 上下文传播
将元数据附加到流中的每个元素会很方便。
例如，从外部数据源读取数据时，跟踪读取的偏移量可能很有用，因此当元素到达接收器时，可以将其标记为已处理。
对于此用例，我们在Source和Flow上提供SourceWithContext和FlowWithContext变体。
从本质上讲，FlowWithContext只是一个包含成对的元素和上下文的Flow，但是优点在于运算符：FlowWithContext上的大多数运算符将在元素上而不是在该元素上工作，从而使您可以专注于应用程序逻辑而不必担心关于上下文。
# 限制条件
并非Flow上所有可用的操作在FlowWithContext上也都可用。这是有意的：在跟踪读取偏移量的用例中，如果允许FlowWithContext任意过滤流并对其进行重新排序，则接收器将无法确定元素是被跳过还是仅被重新排序而仍在运行。
因此，FlowWithContext允许进行过滤操作（例如filter，filterNot，collect等）和分组操作（例如分组，滑动等），但不允许重新排序操作（例如mapAsyncUnordered和statefulMapConcat）。最后，还允许使用诸如mapConcat之类的“一对一”操作。
过滤操作将删除上下文以及删除的元素，而分组操作将保留组中所有元素的上下文。流式传输一对多操作（例如mapConcat）将原始上下文与每个产生的元素相关联。
作为escape hatch，有一个via运算符，可让您插入一个任意Flow，该Flow可以以任何所需的方式处理成对的元素和上下文。使用此运算符时，实现者有责任确保此流程不执行任何可能破坏接收器使用上下文元素的假设的操作（例如重新排序）。
# 创建
创建SourceWithContext的最简单方法是首先创建一个常规Source，其中包含可以从中提取上下文的元素，然后使用Source.asSourceWithContext。
# 组合
当您有一个SourceWithContext源生成的Foo类型的元素具有Ctx类型的上下文，并且有一个从Foo到Bar的流时，您不能简单地使用source.via（flow）到达一个SourceWithContext并生成带有上下文的Bar类型的元素 类型为Ctx。 这样做的原因是流程可能会重新排列流经其中的元素，从而难以实施。
当内部Flow中使用的类型具有容纳上下文的空间时，可以使用Flow.asFlowWithContext。 如果不是这种情况，那么更好的解决方案通常是从头开始将流构建为FlowWithContext，而不是先构建Flow并尝试事后将其转换为FlowWithContext。