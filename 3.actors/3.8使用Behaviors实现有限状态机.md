您正在查看新的actor API的文档，以查看Akka Classic文档，请参阅Classic FSM。

actor可用于建模有限状态机(FSM)。

为了证明这一点，请考虑一个actor，该actor在消息突然到达时将接收消息并入队，并在突发结束或收到刷新请求后继续发送消息。

本示例演示如何：

- 使用不同行为建模状态
- 通过将行为表示为方法来在每个状态下建模存储数据
- 实施状态超时

FSM可以接收的事件成为Actor可以接收的消息类型：
```java
```

需要SetTarget来启动它，设置要传递的Batches的目的地； Queue将添加到内部队列，而Flush将标记突发的结束。
```java
```

每个状态都变成一个不同的行为，并且在处理了一条消息之后，将以行为的形式返回下一个状态。

```java
```

@scala [上面的idle方法利用Behaviors.unhandled，它建议系统重用以前的行为，包括未处理消息的提示。 有两种相关的行为：

- 如果您到达不再希望收到消息的状态，则将Behaviors.empty返回为下一个行为。 例如，如果一个actor等到所有生成的子actor都停止了。 未处理的消息仍会记录此行为。
- 如果您不关心未处理的消息，请返回Behaviors.ignore作为下一个行为。 发送给具有这种行为的actor的所有消息都将被简单地丢弃并忽略(不记录)

要设置状态超时，请使用Behaviors.withTimers以及startSingleTimer。

# 示例项目
FSM示例项目是一个示例项目，可以下载并带有如何运行的说明。

该项目包含Dining Hakkers例子，该样本说明了如何使用actor对有限状态机(FSM)进行建模。