在正常情况下，当ActorSystem终止或JVM进程关闭时，某些actor和服务将按特定顺序停止。

Coordinated Shutdown扩展注册了内部和用户定义的任务，这些任务将在关闭过程中执行。 任务按配置定义的"阶段"进行分组，这些阶段定义了关闭顺序。

尤其是before-service-unbind, before-cluster-shutdown和before-actor-system-terminate的阶段专用于特定于应用程序的阶段或任务。

关闭阶段的顺序在akka.coordinated-shutdown.phases中定义。 请参阅reference.conf选项卡中的默认阶段：
```xml

```

如果需要，可以在application.conf添加更多阶段，使用附件的depends-on覆盖阶段。

默认阶段以单个线性顺序定义，但是可以通过定义各阶段之间的依赖性将这些阶段作为有向无环图(DAG)进行排序。 这些阶段按DAG的拓扑排序。

可以将任务添加到此示例中的阶段，该阶段允许某个actor在终止开始之前做出反应：
```java

```
任务完成时，应完成返回的CompletionStage<Done>。 任务名称参数仅用于调试/记录。

在没有任何排序假设的情况下，并行执行添加到同一阶段的任务。 在上一阶段的所有任务完成之前，下一阶段将不会开始。

如果任务没有在配置的超时时间内完成(请参阅reference.conf)，则无论如何将开始下一阶段。 如果任务失败或在超时时间内未完成，则可以为阶段配置recover = off以中止其余的关闭过程。

如果需要取消以前添加的任务：

```java

```

在上面的示例中，可能更方便的是仅在完成关闭后立即停止actor，而不是发送回已完成的消息，并且在actor终止之前关闭任务才能完成。 提供了一种便捷的方法，该方法添加了一个任务，该任务将消息发送给actor，然后监视其终止(新actor API当前没有相应的功能，请参见＃29056)：
```java

```
通常，应在系统启动后尽早注册任务。 在运行时，将执行已注册的协调关闭任务，但添加得太晚的任务将不会运行。

要启动协调关闭过程，您可以在ActorSystem上调用终止()或在CoordinatedShutdown扩展上运行runAll并将其传递给实现CoordinatedShutdown.Reason的类，以供参考：
```java

```
多次调用runAll方法是安全的。它只会运行一次。

这也意味着ActorSystem将在最后一个阶段终止。默认情况下，JVM不会强制停止(如果所有非守护程序线程都已终止，它将停止)。要将System.exit作为最终操作启用，可以配置：
```conf

```
一旦actor系统的根actor停止，协调关闭过程也会开始。

使用Akka集群时，当集群节点将自己视为退出状态时，CoordinatedShutdown将自动运行，即从另一个节点离开将触发离开节点的关闭过程。使用Akka Cluster时，系统会自动添加用于正常退出集群的任务，包括正常关闭Cluster Singleton和Cluster Sharding，即，如果尚未进行正常退出，则运行关闭过程也会触发正常退出。

默认情况下，当JVM进程退出时，例如，CoordinatedShutdown将运行。例如：通过杀死SIGTERM信号(SIGINT ctrl-c不起作用)。可以通过以下方式禁用此行为：
```conf

```

如果您有特定于应用程序的JVM关机钩子，建议您通过CoordinatedShutdown注册它们，以便它们在Akka内部关机钩子之前运行，例如那些关闭了Akka Remoting(Artery)的人。

```java

```
对于某些测试，可能不希望通过CoordinatedShutdown终止ActorSystem。您可以通过在测试中使用的ActorSystem的配置中添加以下内容来禁用它：
```conf

```