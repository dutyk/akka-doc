
您正在查看新的actor API的文档，以查看Akka Classic文档，请参阅Classic Fault Tolerance。

当actor在处理消息时或在初始化过程中引发意外异常，失败时，actor默认情况下将被停止。

>注意
Typeed actor和Classic actor之间的一个重要区别是，默认情况下：如果抛出异常，并且在Classic中重新启动它们时，没有定义监督策略，则前者会停止。

请注意，失败和验证错误之间存在重要区别：

验证错误意味着发送给actor的命令数据无效，应该将其建模为actor协议的一部分，而不是让actor抛出异常。

相反，失败是意外的或actor本身无法控制的事情，例如数据库连接断开。与验证错误相反，将故障建模为协议的一部分几乎没有用，因为发送方几乎不能对此做任何有用的事情。

对于失败，"让它崩溃"的理念很有用：与其将细粒度的恢复和内部状态的校正(由于业务逻辑的失败而部分失效)混合在一起，我们将职责转移到其他地方。在许多情况下，解决方案可能是"crash" actor，并以一个我们知道是有效的新状态开始一个新actor。

# 监督
在Akka中，"其他地方"称为监督。监督允许您声明性地描述，当在actor中引发某些类型的异常时应该发生的情况。

默认的监督策略是在引发异常时停止actor。在许多情况下，您将需要进一步自定义此行为。要使用监督，实际的Actor行为将使用Behaviors.supervise进行包装。通常，在将其作为子级生成时，会将其包裹在父级的监督下。

此示例在actor失败并出现IllegalStateException时重新启动它：
```java
```
或者，要继续操作，请忽略故障并处理下一条消息，而不是：
```java
```

可以使用更复杂的重启策略，例如 在10秒钟内重启不超过10次：
```java
```

要使用不同的策略处理不同的异常，可以嵌套对监督的调用：
```java
```

有关策略的完整列表，请参见SupervisorStrategy上的公共方法。

>注意
重新启动行为后，将重新安装提供给Behaviors.supervise的原始Behavior，这意味着如果它包含可变状态，则必须通过Behaviors.setup将其设置为工厂。 如果将面向对象的样式与扩展AbstractBehavior的类一起使用，则始终建议按照Behavior工厂方法中所述，通过Behaviors.setup创建样式。 对于功能样式，如果状态是在不可变的参数中捕获的，则通常不需要工厂。

## 包装行为
使用功能样式时，通过更改行为来存储状态非常普遍。
```java
```

进行此监控时，仅需要添加到顶层：
```java
```

每个返回的行为将与监督者自动重新包装。

# 父级重新启动时子级actor停止
子actor通常在setup块中启动，该setup块在重新启动父actor时再次运行。 子actors停止运行，以避免每次重新启动父actor时都会浪费创建新子actors的资源。
```java
```
可以覆盖此设置，以便在重新启动父actor时不会影响子actor。 这样，重新启动的父实例将具有与故障之前相同的子实例。

如果子actor是通过上一个示例中的setup创建的，并且在重新启动父actor时它们应保持完整(不停止)，则应将监督放置在setup 中，并使用SupervisorStrategy.restart().withStopChildren(false)如下所示：
```java
```
这意味着，setup块仅在父actor首次启动时运行，而不在重新启动时运行。

# 预重启信号
在受监管的actor重新启动之前，会发送PreRestart信号，使它有机会清理其创建的资源，就像actor停止时的PostStop信号一样。 从PreRestart信号返回的行为将被忽略。
```java
```

请注意，重新启动不会发出PostStop，因此通常您需要同时处理PreRestart和PostStop来清理资源。

# 上传故障贯穿整个层次
在某些情况下，将有关对故障进行处理的决策向上推到Actor层次结构中，并让父级Actor处理发生故障时应该发生的事情(在经典的Akka Actors中，默认情况下是这样工作的)可能会很有用。

为了在child停止时得到通知，paren必须监督child。如果child因故障而被停止，则会收到ChildFailed信号，其中包含原因。 ChildFailed扩展了Terminated，因此，如果您的用例不需要区分停止还是失败，则可以使用Terminated信号来处理这两种情况。

如果父级又不处理终止的消息，则其自身将失败，并出现akka.actor.typed.DeathPactException。

这意味着actor的层次结构可能会上传子故障，使每个actor都停下来，但会通知最上层的父项有失败以及如何处理，但是，导致失败的原始异常会开箱即用，仅对直接父级可用(这通常是一件好事，不会泄漏实现细节)。

在某些情况下，您可能希望原始异常在层次结构中上传，这可以通过处理Terminated信号并在每个actor中重新抛出异常来完成。
```java
```