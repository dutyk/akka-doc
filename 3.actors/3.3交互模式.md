您正在查看有关新actor API的文档，要查看Akka Classic文档，请参阅Classic Actors。

# 依赖
要使用Akka Actor Typed，必须在项目中添加以下依赖项：
```xml
<properties>
  <akka.version>2.6.8</akka.version>
  <scala.binary.version>2.13</scala.binary.version>
</properties>
<dependency>
  <groupId>com.typesafe.akka</groupId>
  <artifactId>akka-actor-typed_${scala.binary.version}</artifactId>
  <version>${akka.version}</version>
</dependency>
```
# 介绍
通过ActorRef<T>与Akka中的Actor进行交互，其中T是Actor接受的消息类型，也称为"协议"。这样可以确保只能将正确类型的消息发送给Actor，并且除了Actor本身之外，其他任何人都不能访问Actor实例内部。

与Actor进行消息交换遵循以下几种常见模式，下面逐一介绍一下。

# Fire and Forget
与actor互动的基本方法是通过actorRef.tell(message)。可以从任何线程安全地发送带有tell的消息。

Tell是异步的，这意味着该方法立即返回。语句执行后，不能保证收件人已经处理了该消息。这也意味着无法知道消息是否已接收，处理成功还是失败。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/fire-forget.png)

使用给定的协议和actor行为：
```java
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.Behaviors;

public class Printer {
    public static class PrintMe {
        public final String message;

        public PrintMe(String message) {
            this.message = message;
        }
    }

    public static Behavior<PrintMe> create() {
        return Behaviors.setup(
                context ->
                        Behaviors.receive(PrintMe.class)
                                .onMessage(
                                        PrintMe.class,
                                        printMe -> {
                                            context.getLog().info(printMe.message);
                                            return Behaviors.same();
                                        })
                                .build());
    }
}
```
Fire and forget 看起来像这样：
```java
import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;

public class PrinterMain {
    public static void main(String[] args) {
        final ActorSystem<Printer.PrintMe> system =
                ActorSystem.create(Printer.create(), "printer-sample-system");

        // note that system is also the ActorRef to the guardian actor
        final ActorRef<Printer.PrintMe> ref = system;

        // these are all fire and forget
        ref.tell(new Printer.PrintMe("message 1"));
        ref.tell(new Printer.PrintMe("message 2"));
    }
}
```

在以下情况下有用：

- 确保消息已被处理并不重要
- 无法采取行动处理不成功的交付或处理
- 我们希望创建的消息数量最小化，以获得更高的吞吐量(发送响应需要创建两倍的消息数量)

问题：
- 如果消息的流入量高于actor的处理能力，则收件箱将填满，并且在最坏的情况下可能导致JVM崩溃，并显示OutOfMemoryError
- 如果消息丢失，发件人不知道

# 请求-响应
actor之间的许多交互需要从接收者发送回一个或多个响应消息。响应消息可以是查询的结果，某种形式的确认：消息已被接收和处理，或请求订阅的事件。

在Akka中，响应的收件人必须被编码为消息本身中的字段，然后收件人可以使用该字段发送响应(tell)。

例：
![avatar](https://doc.akka.io/docs/akka/current/typed/images/request-response.png)

使用以下协议：
```java
import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.Behaviors;

public class CookieFabric {
    // #request-response-protocol
    public static class Request {
        public final String query;
        public final ActorRef<Response> replyTo;

        public Request(String query, ActorRef<Response> replyTo) {
            this.query = query;
            this.replyTo = replyTo;
        }
    }

    public static class Response {
        public final String result;

        public Response(String result) {
            this.result = result;
        }
    }
    // #request-response-protocol

    // #request-response-respond
    // actor behavior
    public static Behavior<Request> create() {
        return Behaviors.receive(Request.class)
                .onMessage(Request.class, CookieFabric::onRequest)
                .build();
    }

    private static Behavior<Request> onRequest(Request request) {
        // ... process request ...
        request.replyTo.tell(new Response("Here are the cookies for " + request.query));
        return Behaviors.same();
    }
    // #request-response-respond
}
```

发送者将使用自己的ActorRef<Response>(可以通过ActorContext.getSelf()访问)作为ReplyTo。
```java
cookieFabric.tell(new CookieFabric.Request("give me cookies", context.getSelf()));
```

然后在接收方，可以使用ActorRef<Response>将发送一个或多个响应：
```java
// actor behavior
public static Behavior<Request> create() {
  return Behaviors.receive(Request.class)
      .onMessage(Request.class, CookieFabric::onRequest)
      .build();
}

private static Behavior<Request> onRequest(Request request) {
  // ... process request ...
  request.replyTo.tell(new Response("Here are the cookies for " + request.query));
  return Behaviors.same();
}
```

在以下情况下有用：

- 订阅actor，它将发送许多响应消息

问题：

- actor很少将其他actor的响应消息作为其协议的一部分(请参阅 adapted response)
- 很难检测到没有发送或处理消息请求(请参阅ask)
- 除非协议已经包含提供上下文的方法，例如，响应ID中也发送了请求ID，否则在不引入新的单独actor的情况下，不可能将交互绑定到某些特定上下文(请参阅 ask or per session child actor)

# 适应性响应
通常，发送方actor不支持，也不应支持接收其他actor的响应消息。 在这种情况下，我们需要提供正确类型的ActorRef并使响应消息适应发送方Actor可以处理的类型。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/adapted-response.png)

```java
import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;
import java.net.URI;

public class Backend extends AbstractBehavior<Backend.Request> {
    public Backend(ActorContext<Request> context) {
        super(context);
    }

    public static Behavior<Request> create() {
        return Behaviors.setup(context -> new Backend(context));
    }


    @Override
    public Receive<Request> createReceive() {
        return newReceiveBuilder()
                .onMessage(StartTranslationJob.class, this::doTranslate)
                .build();
    }

    private Behavior<Request> doTranslate(StartTranslationJob cmd) {
        getContext().getLog().info("{}, {}", cmd.site, cmd.taskId);
        cmd.replyTo.tell(new JobStarted(cmd.taskId));
        return Behaviors.same();
    }

    public interface Request {}

    public static class StartTranslationJob implements Request {
        public final int taskId;
        public final URI site;
        public final ActorRef<Response> replyTo;

        public StartTranslationJob(int taskId, URI site, ActorRef<Response> replyTo) {
            this.taskId = taskId;
            this.site = site;
            this.replyTo = replyTo;
        }
    }

    public interface Response {}

    public static class JobStarted implements Response {
        public final int taskId;

        public JobStarted(int taskId) {
            this.taskId = taskId;
        }
    }

    public static class JobProgress implements Response {
        public final int taskId;
        public final double progress;

        public JobProgress(int taskId, double progress) {
            this.taskId = taskId;
            this.progress = progress;
        }
    }

    public static class JobCompleted implements Response {
        public final int taskId;
        public final URI result;

        public JobCompleted(int taskId, URI result) {
            this.taskId = taskId;
            this.result = result;
        }
    }
}
```
```java
import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;

public class Frontend {

    public interface Command {}

    public static class Translate implements Command {
        public final URI site;
        public final ActorRef<URI> replyTo;

        public Translate(URI site, ActorRef<URI> replyTo) {
            this.site = site;
            this.replyTo = replyTo;
        }
    }

    private static class WrappedBackendResponse implements Command {
        final Backend.Response response;

        public WrappedBackendResponse(Backend.Response response) {
            this.response = response;
        }
    }

    public static class Translator extends AbstractBehavior<Command> {
        private final ActorRef<Backend.Request> backend;
        private final ActorRef<Backend.Response> backendResponseAdapter;

        private int taskIdCounter = 0;
        private Map<Integer, ActorRef<URI>> inProgress = new HashMap<>();

        public Translator(ActorContext<Command> context, ActorRef<Backend.Request> backend) {
            super(context);
            this.backend = backend;
            this.backendResponseAdapter =
                    context.messageAdapter(Backend.Response.class, WrappedBackendResponse::new);
        }

        public static Behavior<Command> create(ActorRef<Backend.Request> backend) {
            return Behaviors.setup(context -> new Translator(context, backend));
        }

        @Override
        public Receive<Command> createReceive() {
            return newReceiveBuilder()
                    .onMessage(Translate.class, this::onTranslate)
                    .onMessage(WrappedBackendResponse.class, this::onWrappedBackendResponse)
                    .build();
        }

        private Behavior<Command> onTranslate(Translate cmd) {
            taskIdCounter += 1;
            inProgress.put(taskIdCounter, cmd.replyTo);
            backend.tell(
                    new Backend.StartTranslationJob(taskIdCounter, cmd.site, backendResponseAdapter));
            return this;
        }

        private Behavior<Command> onWrappedBackendResponse(WrappedBackendResponse wrapped) {
            Backend.Response response = wrapped.response;
            if (response instanceof Backend.JobStarted) {
                Backend.JobStarted rsp = (Backend.JobStarted) response;
                getContext().getLog().info("Started {}", rsp.taskId);
            } else if (response instanceof Backend.JobProgress) {
                Backend.JobProgress rsp = (Backend.JobProgress) response;
                getContext().getLog().info("Progress {}", rsp.taskId);
            } else if (response instanceof Backend.JobCompleted) {
                Backend.JobCompleted rsp = (Backend.JobCompleted) response;
                getContext().getLog().info("Completed {}", rsp.taskId);
                inProgress.get(rsp.taskId).tell(rsp.result);
                inProgress.remove(rsp.taskId);
            } else {
                return Behaviors.unhandled();
            }

            return this;
        }
    }
}
```
您可以为不同的消息类型注册多个消息适配器。每个消息类只能有一个消息适配器，以确保适配器的数量在反复注册时不会无限增长。这也意味着注册的适配器将替换同一消息类的现有适配器。

如果消息类匹配给定类或为其子类，则将使用消息适配器。以与注册顺序相反的顺序尝试注册的适配器，即最后注册的适配器优先。

消息适配器(返回的ActorRef)与接收actor具有相同的生命周期。建议在顶级Behaviors.setup或AbstractBehavior的构造函数中注册适配器，但以后可以根据需要注册适配器。

适配器功能在接收方actor中运行，并且可以安全地访问其状态，但是如果引发异常，则actor将停止。

在以下情况下有用：

- 在不同的actor消息协议之间进行翻译
- 订阅将发送许多响应消息的actor

问题：

- 很难检测到没有发送或处理消息请求(请参阅 ask)
- 每种响应消息类型只能进行一种适应，如果注册了新的则替换了旧的，例如，如果不同的目标actor使用相同的响应类型，则它们不能具有不同的适应，除非在消息中编码了一些相关性
- 除非协议已经包含提供上下文的方式，例如在响应中也发送请求ID，否则就不可能在不引入新的独立actor的情况下将交互绑定到某些特定上下文

# 两个actor之间请求-响应 ask
在请求和响应之间存在1：1映射的交互中，我们可以在ActorContext上使用ask与另一个actor进行交互。

交互有两个步骤，首先，我们需要构造传出消息，为此，我们需要将ActorRef<Response>作为收件人放入传出消息中。第二步是将成功的响应或失败转换为消息，该消息是发送方的协议的一部分。另请参见通用响应包装器，以获取成功或错误的答复。

例：
![avatar](https://doc.akka.io/docs/akka/current/typed/images/ask-from-actor.png)

```java
```

响应调整函数在接收方actor中运行，并且可以安全地访问其状态，但是如果抛出异常，则actor被停止。

在以下情况下有用：

- 单一响应查询
- actor需要在继续之前知道消息已被处理
- 如果没有及时做出回应，允许actor重新发送
- 跟踪未完成的请求，而不是使接收者感到不知所措("背压")
- 上下文应加到交互中，但协议不支持该上下文(请求ID，响应所针对的查询)

问题：

- 一个问题只能有一个响应(请参见每个session子actor)
- 当请求超时，接收方actor不知道并且可能仍会对其进行处理直至完成，甚至在事实发生之后就开始处理它。
- 找一个好的超时时间，尤其是当Ask触发接收方actor中的链式Ask。您希望短暂的超时，能够响应并回答请求者，但同时您不希望有很多误报

# 来自actor外部请求-响应ask
有时您需要与actor系统外部的actor进行交互，这可以通过如上所述的 fire-and-forget 实现，也可以通过另一个版本的ask来完成，后者会返回CompletionStage<Response>，该CompletionStage<Response>可以通过成功的响应，或在指定的超时时间内没有响应，则失败并显示TimeoutException。

为此，我们使用akka.actor.typed.javadsl.AskPattern.ask将消息发送给actor并获取CompletionState[Response]。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/ask-from-outside.png)
```java
```

请注意，验证错误暴露在消息协议中。 GiveMeCookies请求可以使用Cookies或InvalidRequest进行回复。 请求者必须决定如何处理InvalidRequest答复。 有时应将其视为失败的Future，并且可以将回复映射到请求方。 另请参见通用响应包装器，以获取成功或错误的答复。

```java
```

在以下情况下有用：

- 从actor系统外部查询actor

问题：

- 通过返回的CompletionStage上的回调很容易意外地关闭不安全的可变状态，因为这些回调将在不同的线程上执行
- 一个问题只能有一个响应(请参见每个session child actor)
- 当请求超时，接收方actor不知道并且可能仍会对其进行处理直至完成，甚至在事实发生之后就开始处理它。

# 通用响应包装
在许多情况下，响应可能是成功的结果，也可能是错误(例如，验证错误，该命令无效)。必须为每个请求类型定义两个响应类和一个共享的超类型，这可能是重复的，尤其是在群集环境中，在该环境中，您还必须确保可以对消息进行序列化以通过网络发送。

为了解决这个问题，Akka包含了一个通用的状态响应类型：StatusReply，在可以使用Ask的任何地方，还有第二种方法AskWithStatus，假设响应是StatusReply，它将解包成功的响应并帮助处理验证错误。 Akka包括针对该类型的预构建序列化程序，因此在正常使用情况下，集群应用程序仅需要提供序列化程序即可获得成功的结果。

对于成功回复不包含实际值但更多是确认的情况，存在一个预定义的StatusReply.ack()类型的StatusReply<Done>。

错误最好以描述错误之处的文本形式发送，但也可以使用异常来附加类型。

actor对actor的示例：
```java
```

验证错误变成消息适配器的失败。 在这种情况下，我们将显式地处理验证错误与其他询问失败。

示例从外部访问：
```java
```

请注意，验证错误暴露在消息协议中，但是编码为包装器类型，使用StatusReply.error(text)构造：
```java
```

# 忽略回复
在某些情况下，actor对特定的请求消息有响应，但是您对响应不感兴趣。 在这种情况下，您可以传递system.ignoreRef()将request-response转换为 fire-and-forget。

顾名思义，system.ignoreRef()返回一个ActorRef，它忽略发送给它的任何消息。

使用与上述request-response相同的协议，如果发件人希望忽略应答，则可以将system.ignoreRef()传递给replyTo，可以通过ActorContext.getSystem().ignoreRef()进行访问。
```java
```

在以下情况下有用：

- 发送消息，协议定义了答复，但是您对接收答复不感兴趣

问题：

- 返回的ActorRef将忽略发送给它的所有消息，因此应谨慎使用。像正常的ActorRef那样不经意地传递它可能会导致actors间的交互中断。
- 从Actor系统外部执行询问时,使用它会导致询问返回的CompletionStage超时，因为它将永远无法完成。
- 最后，监控它是合法的，但是由于它是一种特殊的类型，因此它永远不会终止，您也永远不会收到来自它的终止信号。

# 向自己发送Future Result
使用从actor返回CompletionStage的API时，通常会在CompletionStage完成后使用actor中的响应值。为此，ActorContext提供了pipeToSelf方法。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/pipe-to-self.png)

actorCustomerRepository正在调用CustomerDataAccess上的一个返回CompletionStage的方法。

```java
```

在CompletionStage上仅使用回调可能很诱人，但这会带来访问外部线程不安全的actor内部状态的风险。例如，无法通过此类回调访问上例中的numberOfPendingOperations计数器。因此，最好将结果映射到消息并在接收到该消息时执行进一步的处理。

在以下情况下有用：

- 访问从actor返回CompletionStage的API, 例如数据库或外部服务
- 当CompletionStage完成时，actor需要继续处理
- 保留原始请求的上下文，并在CompletionStage完成后使用上下文，例如，replyTo  actor引用

问题：

- 为结果添加包装消息的样板

# 每个session child actor
某些情况下，只有在从其他actor收集多个答案之后才能创建对请求的完整响应并将其发送回去。对于这种类型的交互，最好将工作委派给每个"session"child actor。子级也可以包含任意逻辑以实现重试，超时失败，截断，进度检查等。

请注意，这本质上是Ask的实现方式，如果您只需要一个带有超时的响应，那么最好使用Ask。

将使用需要执行工作的上下文来创建子对象，包括它可以响应的ActorRef。当有完整的结果存在时，孩子会对结果做出反应并自行停止。

由于会话actor的协议不是公共API，而是父actor的实现细节，因此拥有明确的协议并适应会话actor与之交互的actor的消息可能并不总是有意义。对于此用例，可以表示actor可以接收任何消息(对象)。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/per-session-child.png)
```java
```

在实际的会话子进程中，您可能还希望包括某种形式的超时(请参阅向自身发送消息)。

在以下情况下有用：

- 单个传入请求应导致与其他actor的多种交互，然后才能构建结果，例如汇总多个结果
- 您需要处理确认并重试消息，以便至少一次传递

问题：

- 子actor的生命周期必须加以管理，以免造成资源泄漏，很容易漏掉会话actor没有停止的情况
- 这增加了复杂性，因为每个这样的子代可以与其他子代和父代同时执行

# 通用响应聚合
这类似于上面的 Per session child Actor 模式。有时，可能最终会重复相同的汇总答复方式，并希望将其提取给可重用的actor。

这种模式有很多变体，这就是为什么将其作为文档示例而不是Akka中的内置Behavior提供的原因。旨在根据您的特定需求进行调整。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/aggregator.png)

此示例是预期答复数的汇总。报价请求通过给定的sendRequests函数发送给两个酒店actor，他们两个都使用不同的协议。收集到两个预期的答复后，将它们与给定的gregationReplies函数进行聚合，然后发送回replyTo。如果答复没有在超时时间内到达，则将到目前为止的答复汇总并发送回replyTo。
```java
```
聚合器的实现：
```java
```

在以下情况下有用：

- 汇总答复在多个地方以相同的方式执行，应提取给更通用的actor。
- 单个传入请求应导致与其他actor的多种交互，然后才能构建结果，例如汇总多个结果
- 您需要处理确认并重试消息，以便至少一次传递

问题：

- 具有通用类型的消息协议很困难，因为在运行时会擦除通用类型
- child的生命周期必须加以管理，以免造成资源泄漏，很容易漏掉会话actor没有停止的情况
- 这增加了复杂性，因为每个这样的子代可以与其他子代和父代同时执行

# Latency tail chopping
这是上述通用响应聚合器模式的一种变体。

该算法的目标是在多个目标actor可以执行相同工作且actor偶尔响应速度比预期慢的情况下，减少尾部延迟("减少尾部延迟")。在这种情况下，将相同的工作请求(也称为"备份请求")发送给另一个actor会导致响应时间缩短-因为不太可能多个actor同时承受繁重的工作。杰夫·迪恩(Jeff Dean)关于在大型在线服务中实现快速响应时间的演讲中对这种技术进行了深入的解释。

这种模式有很多变体，这就是为什么将其作为文档示例而不是Akka中的内置Behavior提供的原因。旨在根据您的特定需求进行调整。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/tail-chopping.png)

在以下情况下有用：

- 降低较高的延迟百分位数和延迟变化很重要
- "工作"可以完成多次，并且结果相同, 例如检索信息的请求

问题：

- 由于发送了更多消息并且执行了多次"工作"，因此增加了负载
- 当"工作"不是幂等时，不能使用，只能执行一次
- 具有通用类型的消息协议很困难，因为在运行时会擦除通用类型
- child的生命周期必须加以管理，以免造成资源泄漏，很容易漏掉会话actor没有停止的情况

# 将消息调度到自己
下面的示例演示如何使用计时器将消息调度到actor。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/timer.png)

Buncher actor将一连串的传入消息缓冲，并在超时后或成批消息的数量超过最大大小时，成批分发。
```java
```


这里有几件事值得注意：

- 要访问计时器，请从Behaviors.withTimers开始，它将把TimerScheduler实例传递给函数。可以将其与任何类型的行为一起使用，包括receive，receiveMessage，以及setup或任何其他行为。
- 每个计时器都有一个键，如果启动了具有相同键的新计时器，则前一个计时器将被取消。即使启动新计时器时，该消息已经入队，也可以确保不会收到来自先前计时器的消息。
- 同时支持定期消息计时器和单个消息计时器。
- TimerScheduler本身是可变的，因为它执行和管理注册计划任务的副作用。
- TimerScheduler绑定到拥有它的actor的生命周期，并在actor停止时自动取消。
- Behaviors.withTimers也可以在Behaviors.supervise内部使用，当actor重新启动时，它将自动正确取消启动的计时器，因此新的化身将不会收到前一个化身的预定消息。

## 定期调度
定期消息的调度可以具有两个不同的特征：

- 固定延迟-发送后续消息之间的延迟将始终(至少)为给定的延迟。使用startTimerWithFixedDelay。
- 固定速率-随时间推移的执行频率将达到给定的时间间隔。使用startTimerAtFixedRate。

如果不确定要使用哪一个，则应选择startTimerWithFixedDelay。

使用固定延迟时，如果由于某种原因延迟的调度时间比指定的时间长，它将无法补偿消息之间的延迟。发送后续消息之间的延迟将始终(至少)为给定延迟。从长远来看，消息的频率通常会略低于指定延迟的倒数。

固定延迟执行适用于需要"顺畅"的重复活动。换句话说，对于那些在短期内保持频率准确度比长期保持更为重要的活动是合适的。

当使用固定速率时，如果先前的消息被延迟太长时间，它将补偿后续任务的延迟。在这种情况下，实际的发送间隔将不同于传递给scheduleAtFixedRate方法的间隔。

如果任务延迟的时间间隔大于interval，则将在前一个任务之后立即发送后一条消息。这还导致在长时间的垃圾回收暂停或其他原因(当JVM挂起)之后，所有"丢失的"任务将在进程再次唤醒时执行。例如，scheduleAtFixedRate的间隔为1秒，该过程被挂起30秒钟，将导致快速连续发送30条消息以进行追赶。从长远来看，执行频率将恰好是指定间隔的倒数。

固定速率执行适用于对绝对时间敏感的重复活动，或者执行固定数量执行的总时间很重要的定期活动，例如倒计时计时器，它每秒每秒滴答十秒。

>警告
在长时间的垃圾收集暂停后，scheduleAtFixedRate可能导致计划的消息突发，这在最坏的情况下可能会导致系统上的意外负载。通常首选scheduleWithFixedDelay。

# 对分片actor的回应
当使用Akka Cluster对actor进行分片时，您需要考虑到actor可能会移动或被下线。

期望回复的正常模式是在消息(通常是消息适配器)中包含ActorRef。这可以用于分片的actor，但是如果发送了ctx.getSelf()并且分片的actor被移动或下线，则回复将发送给死信。

一种替代方法是在消息中发送entityId，并通过分片发送答复。

例：

![avatar](https://doc.akka.io/docs/akka/current/typed/images/sharded-response.png)
```java
```
缺点是无法使用消息适配器，因为响应必须以要响应的actor的协议为准。 
另外，如果消息不是静态已知的，则可以将EntityTypeKey包含在消息中。