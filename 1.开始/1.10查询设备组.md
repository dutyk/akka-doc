# Part5 查询设备组

# 介绍
到目前为止，我们所看到的对话模式很简单，因为它们要求参与者保持很少或没有状态。 特别：

设备参与者返回读数，无需更改状态
记录温度，这将更新一个字段
设备组参与者通过在地图中添加或删除条目来维护组成员身份
在这一部分中，我们将使用一个更复杂的示例。 由于房主会对整个房屋的温度感兴趣，因此我们的目标是能够查询一组中的所有设备参与者。 让我们开始研究这种查询API的行为。

# 处理可能的场景

我们面临的第一个问题是组的成员资格是动态的。每个传感器设备均由可以随时停止的演员表示。在查询开始时，我们可以要求所有现有的设备参与者提供当前温度。但是，在查询的生命周期中：

设备参与者可能会停止并且无法通过温度读数进行响应。
一个新的设备参与者可能会启动，并且因为我们不知道而未包含在查询中。
这些问题可以通过许多不同的方式解决，但重要的是要确定所需的行为。以下内容适用于我们的用例：

查询到达时，组参与者会拍摄现有设备参与者的快照，并且只会向这些参与者询问温度。
查询到达后启动的actor将被忽略。
如果快照中的某个参与者在查询过程中停止而没有回答，我们将向查询消息的发送者报告其停止的事实。
除了设备角色动态变化外，一些角色可能需要很长时间才能回答。例如，它们可能卡在意外的无限循环中，或者由于错误而失败并放弃了我们的请求。我们不希望查询无限期地继续，因此在以下两种情况下，我们都将认为查询已完成：

快照中的所有参与者都已响应或已确认已停止。
我们达到了预定的期限。
有了这些决定，再加上快照中的某个设备可能刚刚启动但尚未接收到要记录的温度这一事实，我们可以针对温度查询为每个设备参与者定义四个状态：

它具有可用的温度：温度。
它已响应，但尚无可用温度：TemperatureNotAvailable。
在回答：DeviceNotAvailable之前已停止。
在截止日期DeviceTimedOut之前没有响应。
总结这些消息类型，我们可以在消息协议中添加以下内容：

```java
```

# 实现查询

一种用于实现查询的方法涉及将代码添加到组设备参与者。但是，实际上这可能非常麻烦并且容易出错。请记住，当我们开始查询时，我们需要对存在的设备进行快照并启动计时器，以便我们可以强制执行截止日期。同时，另一个查询可以到达。对于第二个查询，我们需要跟踪完全相同的信息，但要与上一个查询隔离。这将要求我们在查询和设备参与者之间维护单独的映射。

相反，我们将实现一个更简单，更高级的方法。我们将创建一个actor，该actor代表单个查询，并代表团体actor执行完成查询所需的任务。到目前为止，我们已经创建了属于经典领域对象的参与者，但是现在，我们将创建一个代表流程或任务而不是实体的参与者。通过使组设备角色保持简单并能够更好地隔离测试查询功能，我们将从中受益。

定义查询参与者
首先，我们需要设计查询参与者的生命周期。这包括确定其初始状态，将要执行的第一个操作以及在必要时进行的清理。查询参与者将需要以下信息：

要查询的活动设备参与者的快照和ID。
启动查询的请求的ID（以便我们可以将其包括在回复中）。
发送查询的参与者的参考。我们将直接将回复发送给该演员。
指示查询应等待回复的时间的截止日期。将其设为参数将简化测试。
安排查询超时
由于我们需要一种方法来表明我们愿意等待响应的时间，因此现在该引入一个我们尚未使用的新Akka功能，即内置的调度程序功能。使用Behaviors.withTimers和startSingleTimer安排在给定延迟后发送的消息。

我们需要创建一条表示查询超时的消息。我们为此创建了一个简单的消息CollectionTimeout，其中没有任何参数。

在查询开始时，我们需要询问每个设备参与者当前的温度。为了能够快速检测在收到ReadTemperature消息之前已停止的设备，我们还将观察每个参与者。这样，我们就获得了在查询生命周期内停止的那些消息的DeviceTerminated消息，因此我们无需等到超时将它们标记为不可用。

放在一起，我们的DeviceGroupQuery actor的轮廓如下所示：
```java
```

请注意，我们必须将RespondTemperature答复从设备参与者转换为DeviceGroupQuery参与者可以理解的消息协议，即DeviceGroupQueryMessage。为此，我们使用messageAdapter将RespondTemperature包装在WrappedRespondTemperature中，该WrappedRespondTemperature实现DeviceGroupQueryMessage。

追踪演员状态
除了悬而未决的计时器之外，查询参与者还具有一个有状态的方面，它跟踪以下参与者的集合：已答复，已停止或未答复。我们在参与者的可变HashMap中跟踪此状态。

对于我们的用例：

我们通过以下方式跟踪状态：
已收到回复的地图
我们仍在等待的一组演员
我们要执行以下三个事件：
我们可以从其中一台设备接收RespondTemperature消息。
在此期间，我们可以收到有关设备参与者的DeviceTerminated消息。
我们可以在截止日期之前收到CollectionTimeout。
为此，请将以下内容添加到您的DeviceGroupQuery源文件中：

```java
```

对于RespondTemperature和DeviceTerminated，我们通过更新repliesSoFar并从stillWaiting中删除参与者来跟踪答复。 为此，我们可以使用DeviceTerminated消息中已经存在的参与者的标识符。 对于我们的RespondTemperature消息，我们将需要添加以下信息：

```java
```
和
```java
```
处理完每条消息后，我们将委派给一个方法reactWhenAllCollected，我们将在稍后进行讨论。

在超时的情况下，我们需要处理所有尚未答复的参与者（集合的成员stillWaiting），并在最终答复中添加DeviceTimedOut作为状态。

现在，我们必须弄清楚在reactWhenAllCollected中该怎么做。 首先，我们需要将新结果记录在地图的repliesSoFar中，并从stillWaiting中删除actor。 下一步是检查是否有其他演员在等待我们。 如果没有，我们将查询结果发送给原始请求者，并停止查询参与者。 否则，我们需要更新repliesSoFar和stillWaiting结构并等待更多消息。

有了这些知识，我们可以创建responseWhenAllCollected方法：
```java
```

现在我们的查询参与者已经完成：

```java
```

测试查询参与者
现在，让我们验证一下查询参与者实现的正确性。 我们需要对各种场景进行单独测试，以确保一切正常。 为了做到这一点，我们需要以某种方式模拟设备参与者，以行使各种正常或失败的情况。 值得庆幸的是，我们将协作者列表（实际上是Map）作为查询参与者的参数，因此我们可以传递TestProbe引用。 在我们的第一个测试中，我们尝试了两个设备同时都报告温度的情况：
```java
```

那是很高兴的情况，但是我们知道有时设备无法提供温度测量值。 这种情况与之前的情况略有不同：

```java
```
我们也知道，有时设备参与者在回答之前会停下来：
```java
```

如果您还记得，还有另一种情况与设备参与者停止有关。 我们很可能会从设备参与者那里得到正常答复，但是稍后会收到同一参与者的终止消息。 在这种情况下，我们希望保留第一个答复，并且不将设备标记为DeviceNotAvailable。 我们也应该测试一下：


```java
```
最后一种情况是并非所有设备都能及时响应。 为了使测试保持相对快，我们将构造一个具有较小超时的DeviceGroupQuery actor：
```java
```

我们的查询现在按预期工作，现在是时候在DeviceGroup actor中包含此新功能了。


# 为设备组添加查询功能
现在将查询功能包括在group actor中非常简单。 我们对查询参与者本身进行了所有繁重的工作，组参与者仅需要使用正确的初始参数创建它，而无需执行其他操作。

```java
```

可能值得重申本章开始时所说的内容。 通过将仅与查询本身相关的临时状态保留在单独的actor中，我们使group actor实现非常简单。 它会将所有内容委派给儿童演员，因此不必保留与其核心业务无关的状态。 而且，实际上，多个查询现在可以彼此并行运行，实际上可以根据需要运行多个查询。 在我们的情况下，查询单个设备参与者是一项快速的操作，但是例如，如果不是这样，因为需要通过网络联系远程传感器，因此该设计将显着提高吞吐量。

在本章中，我们将测试所有内容是否可以协同工作来结束本章。 此测试是先前测试的变体，现在使用组查询功能：

```java
```

# 总结
在物联网系统的上下文中，本指南特别介绍了以下概念。 如有必要，您可以按照链接进行检查：

参与者的层次结构及其生命周期
设计消息以提高灵活性的重要性
必要时如何观看和阻止演员
# 接下来？

为了继续您的Akka旅程，我们建议：

开始使用Akka构建自己的应用程序，如果遇到困难，请确保您加入我们的社区，以寻求帮助。
如果您需要其他背景知识和详细信息，请阅读其余参考文档，并查看有关Akka的一些书籍和视频。
如果您对函数式编程感兴趣，请阅读如何以函数式样式定义参与者。在本指南中，使用了面向对象的样式，但是您可以根据需要将两者混合使用。
为了使本指南成为一个完整的应用程序，您可能需要提供UI或API。为此，我们建议您研究以下技术，并确定适合您的技术：

Akka HTTP是一个HTTP服务器和客户端库，可以发布和使用HTTP端点
Play Framework是基于Akka HTTP构建的完整的Web框架，它与Akka集成良好，可用于创建完整的现代Web UI
Lagom是一个基于Akka的自以为是的微服务框架，编码了有关Akka和Play的许多最佳实践