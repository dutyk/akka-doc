# Actor模型满足现代、分布式系统要求

如上一主题所述，常见的编程实践无法满足现代系统苛刻的需求。 值得庆幸的是，我们不需要废弃我们所知道的一切。 相反，actor模型以有原则的方式解决了这些缺点，使系统的行为方式与我们的心理模型更匹配。 actor模型抽象使您可以从交流的角度考虑代码，这与大型组织中的人员之间的交流不同。

使用actor可以使我们：

- 强制执行封装而不求助于锁。
- 使用合作实体模型对信号做出反应，更改状态并相互发送信号，以推动整个应用程序前进。
- 不必担心执行机制与我们的世界观不符。

# 使用消息传递避免锁定和阻塞

actor无需调用方法，而是彼此发送消息。发送消息不会将执行线程从发送者转移到目标对象。 actor可以发送消息，继续工作，不会受到阻碍。 因此，它可以在相同的时间内完成更多工作。

对于对象，当方法返回时，它释放对执行线程的控制。 在这方面，acotr的行为很像对象，它们对消息做出反应，并在完成对当前消息的处理后返回执行。 通过这种方式，actor实际上实现了我们为对象设想的执行：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/actor_graph.png)

Actor通过彼此发消息进行交互

传递消息和调用方法之间的重要区别是消息没有返回值。通过发送消息，actor将工作委托给另一个actor。正如我们在[The illusion of a call stack](https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html#the-illusion-of-a-call-stack)看到的那样，如果期望返回值，则发送方actor将需要阻塞或在同一线程上执行其他actor的工作。相反，接收方通过回复消息发送结果。

我们模型中需要进行的第二个关键更改是恢复封装。acotrs对消息做出反应，就像对象对在其上调用的方法“反应”一样。区别在于，不是多个线程“突入”我们的actor，破坏内部状态和不变性。actor独立于消息发送者执行，顺序对传入消息进行响应。每个actor都按顺序处理发送给它的消息，不同的actors会同时并发工作，因此actor系统可以同时处理硬件可以支持的消息。

由于每个actor最多只能处理一条消息，因此不需要同步机制就可以保持actor的不变性。这会自动发生，无需使用锁：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/serialized_timeline_invariants.png)

总之，当actor收到消息时，会发生以下情况：

- actor将消息添加到队列的末尾。
- 如果没有安排actor执行，则将其标记为准备执行。
- 一个（隐藏的）调度程序实体控制actor，开始执行它。
- Actor从队列的前面选择消息。
- Actor修改内部状态，将消息发送给其他Actor。
- actor是没有计划、安排的。

为了完成此行为，actor具有：

- 邮箱（存放消息的队列）。
- 行为behavior（actor的状态，内部变量等）。
- 消息（代表信号的数据片段，类似于方法调用及其参数）。
- 执行环境（一种机制，控制消息发给哪些actors，调用消息处理代码）。
- 地址（稍后会详细介绍）。
  
消息进入actor的邮箱。 actor的行为描述了actor如何响应消息（例如发送更多消息和/或更改状态）。执行环境编排了一个线程池，以完全透明的方式驱动这些动作。

这是一个非常简单的模型，它解决了前面列举的问题：

- 通过将执行与signaling分离（方法调用传递执行，消息传递不传递）来保留封装。
- 不需要锁。只能通过消息修改actor的内部状态，消息一次处理一次，以消除竞争，试图保持不变性。
- 在任何地方都没有使用锁，发送者也不会被阻塞。可以在十几个线程上有效地调度数百万个actors，充分发挥现代CPU的潜力。任务委派是actor的自然操作方式。
- actor的状态是本地的，不共享的，通过消息传播更改和数据，这些消息映射到现代内存层次结构的实际工作方式。在许多情况下，这意味着仅传递包含消息数据的高速缓存行，同时将本地状态和数据保留在原始核心中。相同的模型精确地映射到远程通信，在远程通信中，状态保留在机器的RAM中，更改/数据作为数据包在网络上传播。

# Actor可以很好地处理错误情况

由于actors通过彼此间发消息，不再有共享的调用堆栈，因此我们需要以不同的方式处理错误情况。我们需要考虑两种错误：

- 第一种情况是目标actor上的委派任务由于任务中的错误而失败（通常是某些校验问题，例如不存在的用户ID）。在这种情况下，目标actor封装的服务是完整的，只是任务本身是错误的。服务actor应通过一条消息答复发送者，并提供错误情况。这里没有什么特别的，错误是领域的一部分，因此成为普通消息。
- 第二种情况是服务本身遇到内部故障时。Akka强制将所有actors组织成树状层次结构，即创建另一个actor的actor成为该新actor的父代。这与操作系统将进程组织成树结构非常相似。就像进程一样，当一个actor失败时，其父actor可以决定如何对失败做出反应。同样，如果父actor停止，则其所有子代也将递归停止。这项服务称为监督，它是Akka的核心。

监督策略通常是由父actor启动子actor时定义的。它可以决定在某些类型的故障上重新启动子actor或在其他故障上完全停止它。子actors永远不会默默地死掉（进入无限循环的例外），相反，他们要么失败了，监督者策略可以对错误做出反应，要么停止了（在这种情况下，没有通知关联方）。总有一个负责管理actor的实体：父actor。从外部看不到重新启动：协作actors可以在目标actor重新启动时继续发送消息。

现在，让我们简要浏览一下Akka提供的功能。