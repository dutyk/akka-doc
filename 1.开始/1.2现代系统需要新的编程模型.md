# 为什么现代系统需要新的编程模型

actor模型几十年前由Carl Hewitt提出的，它是一种在高性能网络中处理并行处理的方法，网络环境在某一时刻不可用。 如今，硬件和基础架构功能已经赶上并超越了Hewitt的愿景。 因此，构建具有苛刻要求的分布式系统挑战，这些挑战无法用传统的面向对象编程（OOP）模型完全解决，但可以从actor模型中受益。

如今，actor模型不仅被认为是一种高效的解决方案，而且已经在世界上一些最苛刻的应用程序的投产中得到证明。 为了突出actor模型要解决的问题，本文讨论了传统编程假设与现代多线程、多CPU体系结构的现实之间的不匹配：

- 封装的挑战
- 共享内存在现代计算机体系结构上的错觉
- 调用堆栈的错觉

# 使用消息传递避免锁定和阻塞

actor无需调用方法，而是彼此发送消息。发送消息不会将执行线程从发送者转移到目标对象。 actor可以发送消息，继续工作，不会受到阻碍。 因此，它可以在相同的时间内完成更多工作。

对于对象，当方法返回时，它释放对执行线程的控制。 在这方面，acotr的行为很像对象，它们对消息做出反应，并在完成对当前消息的处理后返回执行。 通过这种方式，actor实际上实现了我们为对象设想的执行：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/actor_graph.png)

Actor通过彼此发消息进行交互

传递消息和调用方法之间的重要区别是消息没有返回值。通过发送消息，actor将工作委托给另一个actor。正如我们在[The illusion of a call stack](https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html#the-illusion-of-a-call-stack)看到的那样，如果期望返回值，则发送方actor将需要阻塞或在同一线程上执行其他actor的工作。相反，接收方通过回复消息发送结果。

我们模型中需要进行的第二个关键更改是恢复封装。acotrs对消息做出反应，就像对象对在其上调用的方法“反应”一样。区别在于，不是多个线程“突入”我们的actor，破坏内部状态和不变性。actor独立于消息发送者执行，顺序对传入消息进行响应。每个actor都按顺序处理发送给它的消息，不同的actors会同时并发工作，因此actor系统可以同时处理硬件可以支持的消息。

由于每个actor最多只能处理一条消息，因此不需要同步机制就可以保持actor的不变性。这会自动发生，无需使用锁：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/serialized_timeline_invariants.png)

总之，当actor收到消息时，会发生以下情况：

- actor将消息添加到队列的末尾。
- 如果没有安排actor执行，则将其标记为准备执行。
- 一个（隐藏的）调度程序实体控制actor，开始执行它。
- Actor从队列的前面选择消息。
- Actor修改内部状态，将消息发送给其他Actor。
- actor是没有计划、安排的。

为了完成此行为，actor具有：

- 邮箱（存放消息的队列）。
- 行为behavior（actor的状态，内部变量等）。
- 消息（代表信号的数据片段，类似于方法调用及其参数）。
- 执行环境（一种机制，控制消息发给哪些actors，调用消息处理代码）。
- 地址（稍后会详细介绍）。
  
消息进入actor的邮箱。 actor的行为描述了actor如何响应消息（例如发送更多消息和/或更改状态）。执行环境编排了一个线程池，以完全透明的方式驱动这些动作。

这是一个非常简单的模型，它解决了前面列举的问题：

- 通过将执行与signaling分离（方法调用传递执行，消息传递不传递）来保留封装。
- 不需要锁。只能通过消息修改actor的内部状态，消息一次处理一次，以消除竞争，试图保持不变性。
- 在任何地方都没有使用锁，发送者也不会被阻塞。可以在十几个线程上有效地调度数百万个actors，充分发挥现代CPU的潜力。任务委派是actor的自然操作方式。
- actor的状态是本地的，不共享的，通过消息传播更改和数据，这些消息映射到现代内存层次结构的实际工作方式。在许多情况下，这意味着仅传递包含消息数据的高速缓存行，同时将本地状态和数据保留在原始核心中。相同的模型精确地映射到远程通信，在远程通信中，状态保留在机器的RAM中，更改/数据作为数据包在网络上传播。

# Actor可以很好地处理错误情况
