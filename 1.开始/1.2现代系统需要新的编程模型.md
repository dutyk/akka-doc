# 为什么现代系统需要新的编程模型

actor模型几十年前由Carl Hewitt提出的，它是一种在高性能网络中处理并行处理的方法，网络环境在某一时刻不可用。 如今，硬件和基础架构功能已经赶上并超越了Hewitt的愿景。 因此，构建具有苛刻要求的分布式系统挑战，这些挑战无法用传统的面向对象编程（OOP）模型完全解决，但可以从actor模型中受益。

如今，actor模型不仅被认为是一种高效的解决方案，而且已经在世界上一些最苛刻的应用程序的投产中得到证明。 为了突出actor模型要解决的问题，本文讨论了传统编程假设与现代多线程、多CPU体系结构的现实之间的不匹配：

- 封装的挑战
- 共享内存在现代计算机体系结构上的错觉
- 调用堆栈的错觉

# 封装的挑战
OOP的核心支柱是封装。 封装要求不能直接从外部访问对象的内部数据。 只能通过调用组织的方法对其进行修改。 该对象负责公开安全操作，以保护其封装数据的不变性。

例如，对有序二叉树实现的操作必须不允许违反树的排序不变性。 调用者希望排序是完整的，并且在查询树中的某些数据时，他们需要能够依赖此约束。

当我们分析OOP运行时行为时，有时会绘制一个消息序列图，展示方法调用的交互。 例如：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/seq_chart.png)

不幸的是，上面的图不能准确地表示执行期间实例的生命线。 实际上，一个线程执行所有这些调用，并且在其调用方法的同一线程上增强不变性。 用执行线程更新该图，看起来像这样：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/seq_chart_thread.png)

当您尝试对多个线程进行建模时，这种澄清的重要性变得很明显。 突然，我们整齐绘制的图表变得不够用。 我们可以尝试说明访问同一实例的多个线程：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/seq_chart_multi_thread.png)

在执行部分，两个线程访问相同的方法。不幸的是，对象的封装模型不能保证该部分中发生的任何事情。两次调用的指令可以以任意方式交错，在不进行某种类型的协调的情况下，两个线程之间无法保持不变性。现在，想象一下这个问题由于存在多个线程而变得更加复杂。

解决此问题的常用方法是在这些方法周围添加锁。尽管这可以确保在任何给定时间最多有一个线程将调用该方法，但这是一种非常昂贵的策略：

- 锁严重限制了并发性，它们在现代CPU体系结构上非常耗费资源，需要从操作系统中进行繁重的工作以挂起线程，稍后进行恢复。
- 现在，调用者线程已被阻止，因此它无法执行任何其他有意义的工作。即使在桌面应用程序中，这也是不能接受的，即使长时间运行后台作业，我们也希望保持面向用户的应用程序部分（其UI）具有响应性。在后端，阻塞是完全浪费的。可能有人认为可以通过启动新线程来弥补这一点，但是线程也是一种昂贵的。
- 锁带来了新的威胁：死锁。

这些现实导致了双向不利的局面：

- 没有足够的锁，状态将被破坏。
- 如果使用许多锁，性能会受到影响，并且很容易导致死锁。

此外，锁只能在本地真正有效地工作。在多台计算机之间进行协调时，唯一的选择是分布式锁。不幸的是，分布式锁的效率要比本地锁低几个数量级，并且通常会对横向扩展施加硬限制。分布式锁定协议需要跨多台计算机在网络上进行几次往返通信，因此延迟会不断增加。

在面向对象的语言中，我们通常很少考虑线程或线性执行。我们经常将系统设想为对象实例的网络，这些对象实例会对方法调用做出反应，修改其内部状态，然后通过方法调用相互通信，从而推动整个应用程序状态向前发展：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/object_graph.png)

但是，在多线程分布式环境中，实际发生的情况是线程通过方法调用来“遍历”对象实例网络。 结果，线程才是真正驱动程序执行的：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/object_graph_snakes.png)

综上所述：

- 对象只能在面对单线程访问时保证封装（保护不变性），多线程执行几乎总是破坏内部状态。在同一代码段中两个竞争线程可以违反每个不变式。
- 尽管锁似乎是维持多线程封装的自然疗法，但实际上，锁效率低下，在任何实际规模的应用中都容易导致死锁。
- 锁在本地工作，试图使它们具有分布式，但限制扩展的潜力。
  
# 共享内存在现代计算机体系结构上的错觉

80、90年代的编程模型概念化地表示，写入变量意味着直接写入内存地址（这有混淆视听，因为局部变量可能只存在于寄存器中）。在现代体系结构上-如果我们稍微简化一些事情-CPU写入高速缓存行，而不是直接写入内存。这些高速缓存中的大多数都位于CPU内核本地，也就是说，一个内核的写操作对另一内核不可见。为了使本地更改对另一个核心（对另一个线程）可见，需要将缓存行传送到另一个核心的缓存中。

在JVM上，我们必须使用易失性标记或Atomic包装器明确表示要在线程之间共享的内存位置。否则，我们只能在锁定的区域中访问它们。我们为什么不将所有变量都标记为volatile？因为跨内核运送缓存行是一项非常昂贵的操作！这样做会隐含地使涉及的内核无法进行额外的工作，并导致高速缓存一致性协议（CPU用来在主内存和其他CPU之间传输高速缓存行的协议）出现瓶颈。结果就是运行效率降低。

即使对于意识到这种情况的开发人员，弄清楚应该将哪些内存位置标记为volatile，或者要使用哪些原子结构也是很困难的。

综上所述：

- 不再有真正的共享内存，CPU核心就像网络上的计算机一样，将数据块（缓存行）彼此显式传递。 CPU间通信和网络通信的共同点比许多人意识到的要多。现在，跨CPU或联网计算机传递消息已成为一种规范。
- 除了通过标记为共享的变量或使用原子数据结构隐藏消息传递之外，更严格和原则性的方法是将状态保持在并发实体本地，并通过消息显式在并发实体之间传播数据或事件。

# 调用堆栈的错觉
现在，我们经常认为调用堆栈是理所当然的。但是，它们是在并发编程不那么重要的时代发明的，因为多CPU系统并不常见。调用堆栈不会跨线程，因此不能为异步调用链建模。

当线程打算将任务委托给“后台”时，就会出现问题。实际上，这意味着委派给另一个线程。这不能是简单的方法/函数调用，因为调用严格地在线程本地。通常发生的情况是，“调用者”将对象放入工作线程（“被调用者”）共享的内存位置，后者又在某个事件循环中将其拾取。这允许“调用者”线程继续进行，并执行其他任务。

第一个问题是，如何将任务完成通知“调用者”？但是，当任务失败并出现异常时，会出现一个更严重的问题。异常传播到哪里？它将传播到工作线程的异常处理程序，完全忽略实际的“调用者”是谁：

![avatar](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/exception_prop.png)

这是一个严重的问题。工作线程如何处理这种情况？它可能无法解决问题，因为它通常忽略了失败任务的目的。需要以某种方式通知“调用者”线程，但是没有调用堆栈可以还原异常。故障通知只能通过辅助渠道完成，例如将错误代码放在“调用方”线程希望得到结果中。如果没有此通知，则“调用者”将永远不会收到有关失败的通知，任务将丢失！令人惊讶的是，这类似于网络系统的工作方式，其中消息/请求可能会丢失/失败，而不会发出任何通知。

当事情真的出错时，这种糟糕的情况变得更糟，后台运行线程的worker遇到错误，最终陷入无法恢复的境地。例如，由错误引起的内部异常会传递到root线程，并导致线程关闭。这立即引发了一个问题，谁应该重新启动线程托管的服务的正常操作，以及如何将其还原到已知的正确状态？乍看之下，这似乎是可以管理的，但我们突然遇到了一个新的意外现象：线程当前正在执行的实际任务不再位于从中获取任务的共享内存（通常是队列） ）。实际上，由于到达顶部的异常使所有调用栈消失，任务状态完全丢失！即使这是本地通信，也没有网络连接（网络通信可能会丢失消息），我们还是丢失了一条消息。

综上所述：

- 为了在当前系统上实现任何有意义的并发和性能，线程必须以高效的方式在彼此之间委派任务，而不会阻塞。使用这种类型的任务委派并发（甚至在网络/分布式计算中更是如此），基于调用堆栈的错误处理会崩溃，需要引入新的显式错误信令机制。失败成为领域模型的一部分。
- 具有工作委派的并发系统需要处理服务故障，并具有从故障中恢复的机制方法。此类服务的客户端需要注意，任务/消息可能会在重新启动期间丢失。即使没有发生损失，由于先前排队的任务（较长的队列），垃圾回收导致的​​延迟等，响应可能会被任意延迟。面对这些情况，并发系统应以超时的形式处理响应截止时间，如网络/分布式系统。

接下来，让我们看看使用actor模型如何克服这些挑战。